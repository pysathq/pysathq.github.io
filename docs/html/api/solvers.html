
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>SAT solvers’ API (pysat.solvers) &#8212; PySAT 1.8.dev2 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Fu&amp;Malik MaxSAT algorithm (pysat.examples.fm)" href="examples/fm.html" />
    <link rel="prev" title="Formula processing (pysat.process)" href="process.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="https://pysathq.github.io">
  <img src="../_static/logo-dark.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <!-- This will display the version of the docs -->
<a href=https://pysathq.github.io/docs/html/index.html><strong>PySAT Documentation (version 1.8.dev2)</strong></a>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pysathq.github.io/docs/pysat.pdf" rel="noopener" target="_blank" title="PDF"><span><i class="fas fa-file"></i></span>
            <label class="sr-only">PDF</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat/issues" rel="noopener" target="_blank" title="Issue tracker"><span><i class="fas fa-bug"></i></span>
            <label class="sr-only">Issue tracker</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-description">
   Module description
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-details">
   Module details
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-pysat.solvers">
<span id="sat-solvers-api-pysat-solvers"></span><h1>SAT solvers’ API (<a class="reference internal" href="#module-pysat.solvers" title="pysat.solvers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.solvers</span></code></a>)<a class="headerlink" href="#module-pysat.solvers" title="Permalink to this headline">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">#</a></h2>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SolverNames</span></code></a></p></td>
<td><p>This class serves to determine the solver requested by a user given a string name.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Solver</span></code></a></p></td>
<td><p>Main class for creating and manipulating a SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cadical103</span></code></p></td>
<td><p>CaDiCaL 1.0.3 SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Cadical153</span></code></p></td>
<td><p>CaDiCaL 1.5.3 SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CryptoMinisat</span></code></p></td>
<td><p>CryptoMinisat solver accessed through <code class="docutils literal notranslate"><span class="pre">pycryptosat</span></code> package.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Gluecard3</span></code></p></td>
<td><p>Gluecard 3 SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Gluecard4</span></code></p></td>
<td><p>Gluecard 4 SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Glucose3</span></code></p></td>
<td><p>Glucose 3 SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Glucose4</span></code></p></td>
<td><p>Glucose 4.1 SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Glucose42</span></code></p></td>
<td><p>Glucose 4.2.1 SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lingeling</span></code></p></td>
<td><p>Lingeling SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapleChrono</span></code></p></td>
<td><p>MapleLCMDistChronoBT SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MapleCM</span></code></p></td>
<td><p>MapleCM SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Maplesat</span></code></p></td>
<td><p>MapleCOMSPS_LRB SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mergesat3</span></code></p></td>
<td><p>MergeSat 3 SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Minicard</span></code></p></td>
<td><p>Minicard SAT solver.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Minisat22</span></code></p></td>
<td><p>MiniSat 2.2 SAT solver.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">MinisatGH</span></code></p></td>
<td><p>MiniSat SAT solver (version from github).</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">#</a></h2>
<p>This module provides <em>incremental</em> access to a few modern SAT solvers. The
solvers supported by PySAT are:</p>
<ul class="simple">
<li><p>CaDiCaL (<a class="reference external" href="https://github.com/arminbiere/cadical">rel-1.0.3</a>)</p></li>
<li><p>Glucose (<a class="reference external" href="http://www.labri.fr/perso/lsimon/glucose/">3.0</a>)</p></li>
<li><p>Glucose (<a class="reference external" href="http://www.labri.fr/perso/lsimon/glucose/">4.1</a>)</p></li>
<li><p>Glucose (<a class="reference external" href="http://www.labri.fr/perso/lsimon/glucose/">4.2.1</a>)</p></li>
<li><p>Lingeling (<a class="reference external" href="http://fmv.jku.at/lingeling/">bbc-9230380-160707</a>)</p></li>
<li><p>MapleLCMDistChronoBT (<a class="reference external" href="http://sat2018.forsyte.tuwien.ac.at/solvers/main_and_glucose_hack/">SAT competition 2018 version</a>)</p></li>
<li><p>MapleCM (<a class="reference external" href="http://sat2018.forsyte.tuwien.ac.at/solvers/main_and_glucose_hack/">SAT competition 2018 version</a>)</p></li>
<li><p>Maplesat (<a class="reference external" href="https://sites.google.com/a/gsd.uwaterloo.ca/maplesat/">MapleCOMSPS_LRB</a>)</p></li>
<li><p>Mergesat (<a class="reference external" href="https://github.com/conp-solutions/mergesat">3.0</a>)</p></li>
<li><p>Minicard (<a class="reference external" href="https://github.com/liffiton/minicard">1.2</a>)</p></li>
<li><p>Minisat (<a class="reference external" href="http://minisat.se/MiniSat.html">2.2 release</a>)</p></li>
<li><p>Minisat (<a class="reference external" href="https://github.com/niklasso/minisat">GitHub version</a>)</p></li>
</ul>
<p>Additionally, PySAT includes the versions of <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code> that support native cardinality constraints, ported from
<code class="xref py py-class docutils literal notranslate"><span class="pre">Minicard</span></code>:</p>
<ul class="simple">
<li><p>Gluecard3</p></li>
<li><p>Gluecard4</p></li>
</ul>
<p>Finally, PySAT offers rudimentary support of CryptoMiniSat5 <a class="footnote-reference brackets" href="#id6" id="id1">3</a> through
the interface provided by the <code class="docutils literal notranslate"><span class="pre">pycryptosat</span></code> package. The functionality
is exposed via the class <code class="xref py py-class docutils literal notranslate"><span class="pre">CryptoMinisat</span></code>. Note that the solver
currently implements only the basic functionality, i.e. adding clauses and
XOR-clauses as well as making (incremental) SAT calls.</p>
<p>All solvers can be accessed through a unified MiniSat-like <a class="footnote-reference brackets" href="#id4" id="id2">1</a> incremental
<a class="footnote-reference brackets" href="#id5" id="id3">2</a> interface described below.</p>
<dl class="footnote brackets">
<dt class="label" id="id4"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Niklas Eén, Niklas Sörensson. <em>An Extensible SAT-solver</em>. SAT 2003.
pp. 502-518</p>
</dd>
<dt class="label" id="id5"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>Niklas Eén, Niklas Sörensson. <em>Temporal induction by incremental SAT
solving</em>. Electr. Notes Theor. Comput. Sci. 89(4). 2003. pp. 543-560</p>
</dd>
<dt class="label" id="id6"><span class="brackets"><a class="fn-backref" href="#id1">3</a></span></dt>
<dd><p>Mate Soos, Karsten Nohl, Claude Castelluccia. <em>Extending SAT
Solvers to Cryptographic Problems</em>. SAT 2009. pp. 244-257</p>
</dd>
</dl>
<p>The module provides direct access to all supported solvers using the
corresponding classes <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MapleChrono</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">MapleCM</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Maplesat</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Mergesat3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Minicard</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Minisat22</span></code>, and <code class="xref py py-class docutils literal notranslate"><span class="pre">MinisatGH</span></code>. However, the solvers can also
be accessed through the common base class <a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> using the solver
<code class="docutils literal notranslate"><span class="pre">name</span></code> argument. For example, both of the following pieces of code
create a copy of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code> solver:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Glucose3</span><span class="p">,</span> <span class="n">Solver</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Glucose3</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;g3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>The <a class="reference internal" href="#module-pysat.solvers" title="pysat.solvers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.solvers</span></code></a> module is designed to create and manipulate SAT
solvers as <em>oracles</em>, i.e. it does not give access to solvers’ internal
parameters such as variable polarities or activities. PySAT provides a user
with the following basic SAT solving functionality:</p>
<ul class="simple">
<li><p>creating and deleting solver objects</p></li>
<li><p>adding individual clauses and formulas to solver objects</p></li>
<li><p>making SAT calls with or without assumptions</p></li>
<li><p>propagating a given set of assumption literals</p></li>
<li><p>setting preferred polarities for a (sub)set of variables</p></li>
<li><p>extracting a model of a satisfiable input formula</p></li>
<li><p>enumerating models of an input formula</p></li>
<li><p>extracting an unsatisfiable core of an unsatisfiable formula</p></li>
<li><p>extracting a <a class="reference external" href="http://www.cs.utexas.edu/~marijn/drup/">DRUP proof</a> logged by the solver</p></li>
</ul>
<p>PySAT supports both non-incremental and incremental SAT solving.
Incrementality can be achieved with the use of the MiniSat-like
<em>assumption-based</em> interface <a class="footnote-reference brackets" href="#id5" id="id7">2</a>. It can be helpful if multiple calls to a
SAT solver are needed for the same formula using different sets of
“assumptions”, e.g. when doing consecutive SAT calls for formula
<span class="math notranslate nohighlight">\(\mathcal{F}\land (a_{i_1}\land\ldots\land a_{i_1+j_1})\)</span> and
<span class="math notranslate nohighlight">\(\mathcal{F}\land (a_{i_2}\land\ldots\land a_{i_2+j_2})\)</span>, where every
<span class="math notranslate nohighlight">\(a_{l_k}\)</span> is an assumption literal.</p>
<p>There are several advantages of using assumptions: (1) it enables one to
<em>keep and reuse</em> the clauses learnt during previous SAT calls at a later
stage and (2) assumptions can be easily used to extract an <em>unsatisfiable
core</em> of the formula. A drawback of assumption-based SAT solving is that
the clauses learnt are longer (they typically contain many assumption
literals), which makes the SAT calls harder.</p>
<p>In PySAT, assumptions should be provided as a list of literals given to the
<code class="docutils literal notranslate"><span class="pre">solve()</span></code> method:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">... </span><span class="c1"># assume that solver s is fed with a formula</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>  <span class="c1"># a simple SAT call</span>
<span class="go">True</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1"># a SAT call with assumption literals</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">get_core</span><span class="p">()</span>  <span class="c1"># extracting an unsatisfiable core</span>
<span class="go">[3, 1]</span>
</pre></div>
</div>
<p>In order to shorten the description of the module, the classes providing
direct access to the individual solvers, i.e. classes <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard4</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose42</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MapleChrono</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MapleCM</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Maplesat</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Mergesat3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Minicard</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Minisat22</span></code>, and <code class="xref py py-class docutils literal notranslate"><span class="pre">MinisatGH</span></code>, are <strong>omitted</strong>. They
replicate the interface of the base class <a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> and, thus, can
be used the same exact way.</p>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">#</a></h2>
<dl class="py exception">
<dt class="sig sig-object py" id="pysat.solvers.NoSuchSolverError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.solvers.</span></span><span class="sig-name descname"><span class="pre">NoSuchSolverError</span></span><a class="headerlink" href="#pysat.solvers.NoSuchSolverError" title="Permalink to this definition">#</a></dt>
<dd><p>This exception is raised when creating a new SAT solver whose name
does not match any name in <a class="reference internal" href="#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-class docutils literal notranslate"><span class="pre">SolverNames</span></code></a>. The list of <em>known</em>
solvers includes the names <cite>‘cadical103’</cite>, <cite>‘cadical153’</cite>,
<cite>‘gluecard3’</cite>, <cite>‘gluecard4’</cite>, <cite>‘glucose3’</cite>, <cite>‘glucose4’</cite>, <cite>glucose42</cite>,
<cite>‘lingeling’</cite>, <cite>‘maplechrono’</cite>, <cite>‘maplecm’</cite>, <cite>‘maplesat’</cite>,
<cite>‘mergesat3’</cite>, <cite>‘minicard’</cite>, <cite>‘minisat22’</cite>, and <cite>‘minisatgh’</cite>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.NoSuchSolverError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.NoSuchSolverError.with_traceback" title="Permalink to this definition">#</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.solvers.Solver">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.solvers.</span></span><span class="sig-name descname"><span class="pre">Solver</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'m22'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_timer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver" title="Permalink to this definition">#</a></dt>
<dd><p>Main class for creating and manipulating a SAT solver. Any available
SAT solver can be accessed as an object of this class and so
<a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> can be seen as a wrapper for all supported solvers.</p>
<p>The constructor of <a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> has only one mandatory argument
<code class="docutils literal notranslate"><span class="pre">name</span></code>, while all the others are default. This means that explicit
solver constructors, e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">MinisatGH</span></code> etc.,
have only default arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<em>str</em>) – solver’s name (see <a class="reference internal" href="#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-class docutils literal notranslate"><span class="pre">SolverNames</span></code></a>).</p></li>
<li><p><strong>bootstrap_with</strong> (<em>iterable</em><em>(</em><em>iterable</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses for solver initialization.</p></li>
<li><p><strong>use_timer</strong> (<em>bool</em>) – whether or not to measure SAT solving time.</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">bootstrap_with</span></code> argument is useful when there is an input CNF
formula to feed the solver with. The argument expects a list of
clauses, each clause being a list of literals, i.e. a list of integers.</p>
<p>If set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, the <code class="docutils literal notranslate"><span class="pre">use_timer</span></code> parameter will force the solver
to accumulate the time spent by all SAT calls made with this solver but
also to keep time of the last SAT call.</p>
<p>Once created and used, a solver must be deleted with the <a class="reference internal" href="#pysat.solvers.Solver.delete" title="pysat.solvers.Solver.delete"><code class="xref py py-meth docutils literal notranslate"><span class="pre">delete()</span></code></a>
method. Alternatively, if created using the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement,
deletion is done automatically when the end of the <code class="docutils literal notranslate"><span class="pre">with</span></code> block is
reached.</p>
<p>Given the above, a couple of examples of solver creation are the
following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span><span class="p">,</span> <span class="n">Minisat22</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;g4&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
<span class="go">[-1, -2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Minisat22</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">m</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
<span class="go">[-1, -2]</span>
</pre></div>
</div>
<p>Note that while all explicit solver classes necessarily have default
arguments <code class="docutils literal notranslate"><span class="pre">bootstrap_with</span></code> and <code class="docutils literal notranslate"><span class="pre">use_timer</span></code>, solvers
<code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose42</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MapleChrono</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">MapleCM</span></code>, and <code class="xref py py-class docutils literal notranslate"><span class="pre">Maplesat</span></code> can have additional default
arguments. One such argument supported by is <a class="reference external" href="http://www.cs.utexas.edu/~marijn/drup/">DRUP proof</a> logging. This can be
enabled by setting the <code class="docutils literal notranslate"><span class="pre">with_proof</span></code> argument to <code class="docutils literal notranslate"><span class="pre">True</span></code> (<code class="docutils literal notranslate"><span class="pre">False</span></code>
by default):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Lingeling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># pigeonhole principle for 3 pigeons</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Lingeling</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">,</span> <span class="n">with_proof</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">l</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">l</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">... </span>    <span class="n">l</span><span class="o">.</span><span class="n">get_proof</span><span class="p">()</span>
<span class="go">[&#39;-5 0&#39;, &#39;6 0&#39;, &#39;-2 0&#39;, &#39;-4 0&#39;, &#39;1 0&#39;, &#39;3 0&#39;, &#39;0&#39;]</span>
</pre></div>
</div>
<p>Additionally, Glucose-based solvers, namely <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose42</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard3</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Gluecard4</span></code> have one more default argument <code class="docutils literal notranslate"><span class="pre">incr</span></code> (<code class="docutils literal notranslate"><span class="pre">False</span></code>
by default), which enables incrementality features introduced in
Glucose3 <a class="footnote-reference brackets" href="#id10" id="id8">4</a>. To summarize, the additional arguments of Glucose are:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>incr</strong> (<em>bool</em>) – enable the incrementality features of Glucose3 <a class="footnote-reference brackets" href="#id10" id="id9">4</a>.</p></li>
<li><p><strong>with_proof</strong> (<em>bool</em>) – enable proof logging in the <a class="reference external" href="http://www.cs.utexas.edu/~marijn/drup/">DRUP format</a>.</p></li>
</ul>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id10"><span class="brackets">4</span><span class="fn-backref">(<a href="#id8">1</a>,<a href="#id9">2</a>)</span></dt>
<dd><p>Gilles Audemard, Jean-Marie Lagniez, Laurent Simon. <em>Improving
Glucose for Incremental SAT Solving with Assumptions: Application
to MUS Extraction</em>. SAT 2013. pp. 309-317</p>
</dd>
</dl>
<p>Finally, most MiniSat-based solvers can be exploited in the
“warm-start” mode in the case of <em>satisfiable</em> formulas. This may come
in handy in various model enumeration settings. Note that warm-start
mode is disabled in the case of limited solving with <em>“unknown”</em>
outcomes. Warm-start mode can be set with the use of the <cite>warm_start</cite>
parameter:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>warm_start</strong> (<em>bool</em>) – use the solver in the “warm-start” mode</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.accum_stats">
<span class="sig-name descname"><span class="pre">accum_stats</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.accum_stats" title="Permalink to this definition">#</a></dt>
<dd><p>Get accumulated low-level stats from the solver. Currently, the
statistics includes the number of restarts, conflicts, decisions,
and propagations.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">accum_stats</span><span class="p">())</span>
<span class="go">False</span>
<span class="go">{&#39;restarts&#39;: 2, &#39;conflicts&#39;: 201, &#39;decisions&#39;: 254, &#39;propagations&#39;: 2321}</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.add_atmost">
<span class="sig-name descname"><span class="pre">add_atmost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.add_atmost" title="Permalink to this definition">#</a></dt>
<dd><p>This method is responsible for adding a new <em>native</em> AtMostK (see
<a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a>) constraint.</p>
<p><strong>Note that most of the solvers do not support native AtMostK
constraints</strong>.</p>
<p>An AtMostK constraint is <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\leq k\)</span>. A
native AtMostK constraint should be given as a pair <code class="docutils literal notranslate"><span class="pre">lits</span></code> and
<code class="docutils literal notranslate"><span class="pre">k</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals.</p></li>
<li><p><strong>k</strong> (<em>int</em>) – upper bound on the number of satisfied literals</p></li>
<li><p><strong>no_return</strong> (<em>bool</em>) – check solver’s internal formula and return the
result, if set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool if <code class="docutils literal notranslate"><span class="pre">no_return</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<p>A usage example is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mc&#39;</span><span class="p">,</span> <span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_atmost</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">no_return</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the AtMostK constraint is in conflict with initial unit clauses</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.add_clause">
<span class="sig-name descname"><span class="pre">add_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.add_clause" title="Permalink to this definition">#</a></dt>
<dd><p>This method is used to add a single clause to the solver. An
optional argument <code class="docutils literal notranslate"><span class="pre">no_return</span></code> controls whether or not to check
the formula’s satisfiability after adding the new clause.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – an iterable over literals.</p></li>
<li><p><strong>no_return</strong> (<em>bool</em>) – check solver’s internal formula and return the
result, if set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool if <code class="docutils literal notranslate"><span class="pre">no_return</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<p>Note that a clause can be either a <code class="docutils literal notranslate"><span class="pre">list</span></code> of integers or another
iterable type over integers, e.g. <code class="docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="docutils literal notranslate"><span class="pre">set</span></code> among
others.</p>
<p>A usage example is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">no_return</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.add_xor_clause">
<span class="sig-name descname"><span class="pre">add_xor_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.add_xor_clause" title="Permalink to this definition">#</a></dt>
<dd><p>Add a new XOR clause to solver’s internal formula. The input
parameters include the list of literals and the right-hand side
(the value of the sum).</p>
<p><strong>Note that XOR clauses are currently supported only by
CryptoMinisat.</strong></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – list of literals in the clause (left-hand side)</p></li>
<li><p><strong>value</strong> (<em>bool</em>) – value of the sum (right-hand-side)</p></li>
</ul>
</dd>
</dl>
<p>A usage example is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;cms&#39;</span><span class="p">,</span> <span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> <span class="k">as</span> <span class="n">solver</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">solver</span><span class="o">.</span><span class="n">add_xor_clause</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">solver</span><span class="o">.</span><span class="n">enum_models</span><span class="p">():</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">[-1, 2, 3]</span>
<span class="go">[1, -2, 3]</span>
<span class="go">[1, -2, -3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.append_formula">
<span class="sig-name descname"><span class="pre">append_formula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_return</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.append_formula" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used to add a given list of clauses into the
solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<em>iterable</em><em>(</em><em>iterable</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses.</p></li>
<li><p><strong>no_return</strong> (<em>bool</em>) – check solver’s internal formula and return the
result, if set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p></li>
</ul>
</dd>
</dl>
<p>The <code class="docutils literal notranslate"><span class="pre">no_return</span></code> argument is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool if <code class="docutils literal notranslate"><span class="pre">no_return</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">... </span><span class="c1"># assume the formula contains clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">append_formula</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">,</span> <span class="n">no_return</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.clear_interrupt">
<span class="sig-name descname"><span class="pre">clear_interrupt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.clear_interrupt" title="Permalink to this definition">#</a></dt>
<dd><p>Clears a previous interrupt. If a limited SAT call was interrupted
using the <a class="reference internal" href="#pysat.solvers.Solver.interrupt" title="pysat.solvers.Solver.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a> method, this method <strong>must be called</strong>
before calling the SAT solver again.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.conf_budget">
<span class="sig-name descname"><span class="pre">conf_budget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">budget</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.conf_budget" title="Permalink to this definition">#</a></dt>
<dd><p>Set limit (i.e. the upper bound) on the number of conflicts in the
next limited SAT call (see <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>). The limit value
is given as a <code class="docutils literal notranslate"><span class="pre">budget</span></code> variable and is an integer greater than
<code class="docutils literal notranslate"><span class="pre">0</span></code>.  If the budget is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">-1</span></code>, the upper bound on
the number of conflicts is disabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>budget</strong> (<em>int</em>) – the upper bound on the number of conflicts.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">MinisatGH</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>  <span class="c1"># PHP20 is too hard for a SAT solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MinisatGH</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">conf_budget</span><span class="p">(</span><span class="mi">2000</span><span class="p">)</span>  <span class="c1"># getting at most 2000 conflicts</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">solve_limited</span><span class="p">())</span>  <span class="c1"># making a limited oracle call</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.configure">
<span class="sig-name descname"><span class="pre">configure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">parameters</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.configure" title="Permalink to this definition">#</a></dt>
<dd><p>Configure <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code> by setting some of the predefined
parameters to selected values. Note that this method can be
invoked only for <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code> – no other solvers support
this for now.</p>
<p>Also note that this call must follow the creation of the new
solver object; otherwise, an exception may be thrown.</p>
<p>The list of available options of <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code> and the
corresponding values they can be assigned to is provided <a class="reference external" href="https://github.com/arminbiere/cadical/blob/master/src/options.hpp">here</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>parameters</strong> (<em>dict</em>) – parameter names mapped to integer values</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.dec_budget">
<span class="sig-name descname"><span class="pre">dec_budget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">budget</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.dec_budget" title="Permalink to this definition">#</a></dt>
<dd><p>Set limit (i.e. the upper bound) on the number of decisions in
the next limited SAT call (see <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>). The limit
value is given as a <code class="docutils literal notranslate"><span class="pre">budget</span></code> variable and is an integer greater
than <code class="docutils literal notranslate"><span class="pre">0</span></code>. If the budget is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">-1</span></code>, the upper
bound on the number of decisions is disabled.</p>
<p>Note that this functionality is supported by <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code>
and <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code> only!</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>budget</strong> (<em>int</em>) – the upper bound on the number of decisions.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Cadical153</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">Parity</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># too hard for a SAT solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Cadical153</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">dec_budget</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>  <span class="c1"># doing at most 500 decisions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">solve_limited</span><span class="p">())</span>  <span class="c1"># making a limited oracle call</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.delete" title="Permalink to this definition">#</a></dt>
<dd><p>Solver destructor, which must be called explicitly if the solver
is to be removed. This is not needed inside an <code class="docutils literal notranslate"><span class="pre">with</span></code> block.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.enum_models">
<span class="sig-name descname"><span class="pre">enum_models</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.enum_models" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used to enumerate models of a CNF formula and
it performs as a standard Python iterator. The method can be
called without arguments but also with an argument
<code class="docutils literal notranslate"><span class="pre">assumptions</span></code>, which represents a list of literals to “assume”.</p>
<p><strong>Note</strong> that the method expects the list of assumption literals
(if any) to contain <strong>no duplicate literals</strong>. Otherwise, it is
not guaranteed to run correctly. As such, a user is recommended to
explicitly filter out duplicate literals from the assumptions list
before calling <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>, <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>,
<a class="reference internal" href="#pysat.solvers.Solver.propagate" title="pysat.solvers.Solver.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, or <a class="reference internal" href="#pysat.solvers.Solver.enum_models" title="pysat.solvers.Solver.enum_models"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enum_models()</span></code></a>.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Once finished, model enumeration results in the target formula
being <em>unsatisfiable</em>. This is because the enumeration process
<em>blocks</em> each previously computed model by adding a new
clause until no more models of the formula exist.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>assumptions</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of assumption literals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(int).</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">enum_models</span><span class="p">():</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">[-1, -2, -3]</span>
<span class="go">[-1, -2, 3]</span>
<span class="go">[-1, 2, 3]</span>
<span class="go">[1, 2, 3]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">enum_models</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="go">[1, 2, 3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.get_core">
<span class="sig-name descname"><span class="pre">get_core</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.get_core" title="Permalink to this definition">#</a></dt>
<dd><p>This method is to be used for extracting an unsatisfiable core in
the form of a subset of a given set of assumption literals, which
are responsible for unsatisfiability of the formula. This can be
done only if the previous SAT call returned <code class="docutils literal notranslate"><span class="pre">False</span></code> (<em>UNSAT</em>).
Otherwise, <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(int) or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Minisat22</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">Minisat22</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get_core</span><span class="p">())</span>  <span class="c1"># literals 2 and 3 are not in the core</span>
<span class="go">[-4, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.get_model">
<span class="sig-name descname"><span class="pre">get_model</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.get_model" title="Permalink to this definition">#</a></dt>
<dd><p>The method is to be used for extracting a satisfying assignment for
a CNF formula given to the solver. A model is provided if a
previous SAT call returned <code class="docutils literal notranslate"><span class="pre">True</span></code>. Otherwise, <code class="docutils literal notranslate"><span class="pre">None</span></code> is
reported.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(int) or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">get_model</span><span class="p">())</span>
<span class="go">[-1, -2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.get_proof">
<span class="sig-name descname"><span class="pre">get_proof</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.get_proof" title="Permalink to this definition">#</a></dt>
<dd><p>A DRUP proof can be extracted using this method if the solver was
set up to provide a proof. Otherwise, the method returns <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list(str) or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;g4&#39;</span><span class="p">,</span> <span class="n">with_proof</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">g</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">g</span><span class="o">.</span><span class="n">append_formula</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">g</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">False</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get_proof</span><span class="p">())</span>
<span class="go">[&#39;-8 4 1 0&#39;, &#39;-10 0&#39;, &#39;-2 0&#39;, &#39;-4 0&#39;, &#39;-8 0&#39;, &#39;-6 0&#39;, &#39;0&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.get_status">
<span class="sig-name descname"><span class="pre">get_status</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.get_status" title="Permalink to this definition">#</a></dt>
<dd><p>The result of a previous SAT call is stored in an internal
variable and can be later obtained using this method.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p><code class="docutils literal notranslate"><span class="pre">None</span></code> is returned if a previous SAT call was interrupted.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.interrupt">
<span class="sig-name descname"><span class="pre">interrupt</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.interrupt" title="Permalink to this definition">#</a></dt>
<dd><p>Interrupt the execution of the current <em>limited</em> SAT call (see
<a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>). Can be used to enforce time limits using
timer objects. The interrupt must be cleared before performing
another SAT call (see <a class="reference internal" href="#pysat.solvers.Solver.clear_interrupt" title="pysat.solvers.Solver.clear_interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_interrupt()</span></code></a>).</p>
<p><strong>Note</strong> that this method can be called if limited SAT calls are
made with the option <code class="docutils literal notranslate"><span class="pre">expect_interrupt</span></code> set to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Behaviour is <strong>undefined</strong> if used to interrupt a <em>non-limited</em>
SAT call (see <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>).</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">MinisatGH</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">threading</span> <span class="kn">import</span> <span class="n">Timer</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>  <span class="c1"># PHP20 is too hard for a SAT solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MinisatGH</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">interrupt</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">s</span><span class="o">.</span><span class="n">interrupt</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timer</span> <span class="o">=</span> <span class="n">Timer</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">,</span> <span class="p">[</span><span class="n">m</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">timer</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">solve_limited</span><span class="p">(</span><span class="n">expect_interrupt</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.new">
<span class="sig-name descname"><span class="pre">new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'m22'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_timer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.new" title="Permalink to this definition">#</a></dt>
<dd><p>The actual solver constructor invoked from <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>. Chooses
the solver to run, based on its name. See <a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> for the
parameters description.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pysat.solvers.NoSuchSolverError" title="pysat.solvers.NoSuchSolverError"><strong>NoSuchSolverError</strong></a> – if there is no solver matching the given
name.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.nof_clauses">
<span class="sig-name descname"><span class="pre">nof_clauses</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.nof_clauses" title="Permalink to this definition">#</a></dt>
<dd><p>This method returns the number of clauses currently appearing in
the formula given to the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nof_clauses</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.nof_vars">
<span class="sig-name descname"><span class="pre">nof_vars</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.nof_vars" title="Permalink to this definition">#</a></dt>
<dd><p>This method returns the number of variables currently appearing in
the formula given to the solver.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">nof_vars</span><span class="p">()</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.prop_budget">
<span class="sig-name descname"><span class="pre">prop_budget</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">budget</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.prop_budget" title="Permalink to this definition">#</a></dt>
<dd><p>Set limit (i.e. the upper bound) on the number of propagations in
the next limited SAT call (see <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>). The limit
value is given as a <code class="docutils literal notranslate"><span class="pre">budget</span></code> variable and is an integer greater
than <code class="docutils literal notranslate"><span class="pre">0</span></code>. If the budget is set to <code class="docutils literal notranslate"><span class="pre">0</span></code> or <code class="docutils literal notranslate"><span class="pre">-1</span></code>, the upper
bound on the number of propagations is disabled.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>budget</strong> (<em>int</em>) – the upper bound on the number of propagations.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">MinisatGH</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">Parity</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">Parity</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># too hard for a SAT solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span> <span class="o">=</span> <span class="n">MinisatGH</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">prop_budget</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>  <span class="c1"># doing at most 100000 propagations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">solve_limited</span><span class="p">())</span>  <span class="c1"># making a limited oracle call</span>
<span class="go">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">m</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.propagate">
<span class="sig-name descname"><span class="pre">propagate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phase_saving</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.propagate" title="Permalink to this definition">#</a></dt>
<dd><p>The method takes a list of assumption literals and does unit
propagation of each of these literals consecutively. A Boolean
status is returned followed by a list of assigned (assumed and also
propagated) literals. The status is <code class="docutils literal notranslate"><span class="pre">True</span></code> if no conflict arised
during propagation. Otherwise, the status is <code class="docutils literal notranslate"><span class="pre">False</span></code>.
Additionally, a user may specify an optional argument
<code class="docutils literal notranslate"><span class="pre">phase_saving</span></code> (<code class="docutils literal notranslate"><span class="pre">0</span></code> by default) to enable MiniSat-like phase
saving.</p>
<p><strong>Note</strong> that the method expects the list of assumption literals
(if any) to contain <strong>no duplicate literals</strong>. Otherwise, it is
not guaranteed to run correctly. As such, a user is recommended to
explicitly filter out duplicate literals from the assumptions list
before calling <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>, <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>,
<a class="reference internal" href="#pysat.solvers.Solver.propagate" title="pysat.solvers.Solver.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, or <a class="reference internal" href="#pysat.solvers.Solver.enum_models" title="pysat.solvers.Solver.enum_models"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enum_models()</span></code></a>.</p>
<p><strong>Note</strong> that only MiniSat-like solvers and CaDiCaL 1.5.3 support
this functionality (e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code> do not support it).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>assumptions</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of assumption literals.</p></li>
<li><p><strong>phase_saving</strong> (<em>int</em>) – enable phase saving (can be <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, and
<code class="docutils literal notranslate"><span class="pre">2</span></code>).</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple(bool, list(int)).</p>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Glucose3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="o">*</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">atmost</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span> <span class="n">bound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Glucose3</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(True, [1, -2, -3, -4, -5])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">propagate</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="go">(False, [])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.set_phases">
<span class="sig-name descname"><span class="pre">set_phases</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">literals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.set_phases" title="Permalink to this definition">#</a></dt>
<dd><p>The method takes a list of literals as an argument and sets
<em>phases</em> (or MiniSat-like <em>polarities</em>) of the corresponding
variables respecting the literals. For example, if a given list of
literals is <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">-513]</span></code>, the solver will try to set variable
<span class="math notranslate nohighlight">\(x_1\)</span> to true while setting <span class="math notranslate nohighlight">\(x_{513}\)</span> to false.</p>
<p><strong>Note</strong> that once these preferences are specified,
<code class="xref py py-class docutils literal notranslate"><span class="pre">MinisatGH</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code> will always respect them
when branching on these variables. However, solvers
<code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose3</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Glucose4</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">MapleChrono</span></code>,
<code class="xref py py-class docutils literal notranslate"><span class="pre">MapleCM</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Maplesat</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Minisat22</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Minicard</span></code> can redefine the preferences in any of the
following SAT calls due to the phase saving heuristic.</p>
<p>Also <strong>note</strong> that <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code> do
not support this functionality.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>literals</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals.</p>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Glucose3</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Glucose3</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula has 3 models: [-1, 2], [1, -2], [1, 2]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">set_phases</span><span class="p">(</span><span class="n">literals</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">get_model</span><span class="p">()</span>
<span class="go">[1, 2]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.solve">
<span class="sig-name descname"><span class="pre">solve</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.solve" title="Permalink to this definition">#</a></dt>
<dd><p>This method is used to check satisfiability of a CNF formula given
to the solver (see methods <a class="reference internal" href="#pysat.solvers.Solver.add_clause" title="pysat.solvers.Solver.add_clause"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_clause()</span></code></a> and
<a class="reference internal" href="#pysat.solvers.Solver.append_formula" title="pysat.solvers.Solver.append_formula"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append_formula()</span></code></a>). Unless interrupted with SIGINT, the
method returns either <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>Incremental SAT calls can be made with the use of assumption
literals. (<strong>Note</strong> that the <code class="docutils literal notranslate"><span class="pre">assumptions</span></code> argument is optional
and disabled by default.)</p>
<p><strong>Note</strong> that the method expects the list of assumption literals
(if any) to contain <strong>no duplicate literals</strong>. Otherwise, it is
not guaranteed to run correctly. As such, a user is recommended to
explicitly filter out duplicate literals from the assumptions list
before calling <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>, <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>,
<a class="reference internal" href="#pysat.solvers.Solver.propagate" title="pysat.solvers.Solver.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, or <a class="reference internal" href="#pysat.solvers.Solver.enum_models" title="pysat.solvers.Solver.enum_models"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enum_models()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>assumptions</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of assumption literals.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">])</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.solve_limited">
<span class="sig-name descname"><span class="pre">solve_limited</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">expect_interrupt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.solve_limited" title="Permalink to this definition">#</a></dt>
<dd><p>This method is used to check satisfiability of a CNF formula given
to the solver (see methods <a class="reference internal" href="#pysat.solvers.Solver.add_clause" title="pysat.solvers.Solver.add_clause"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_clause()</span></code></a> and
<a class="reference internal" href="#pysat.solvers.Solver.append_formula" title="pysat.solvers.Solver.append_formula"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append_formula()</span></code></a>), taking into account the upper bounds on
the <em>number of conflicts</em> (see <a class="reference internal" href="#pysat.solvers.Solver.conf_budget" title="pysat.solvers.Solver.conf_budget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conf_budget()</span></code></a>) and the <em>number
of propagations</em> (see <a class="reference internal" href="#pysat.solvers.Solver.prop_budget" title="pysat.solvers.Solver.prop_budget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prop_budget()</span></code></a>). If the number of
conflicts or propagations is set to be larger than 0 then the
following SAT call done with <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a> will not exceed
these values, i.e. it will be <em>incomplete</em>. Otherwise, such a call
will be identical to <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>.</p>
<p>As soon as the given upper bound on the number of conflicts or
propagations is reached, the SAT call is dropped returning
<code class="docutils literal notranslate"><span class="pre">None</span></code>, i.e. <em>unknown</em>. <code class="docutils literal notranslate"><span class="pre">None</span></code> can also be returned if the call
is interrupted by SIGINT. Otherwise, the method returns <code class="docutils literal notranslate"><span class="pre">True</span></code> or
<code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p><strong>Note</strong> that only MiniSat-like solvers support this functionality
(e.g. <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical103</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">Cadical153</span></code>, and
<code class="xref py py-class docutils literal notranslate"><span class="pre">Lingeling</span></code> do not support it).</p>
<p>Incremental SAT calls can be made with the use of assumption
literals. (<strong>Note</strong> that the <code class="docutils literal notranslate"><span class="pre">assumptions</span></code> argument is optional
and disabled by default.)</p>
<p><strong>Note</strong> that the method expects the list of assumption literals
(if any) to contain <strong>no duplicate literals</strong>. Otherwise, it is
not guaranteed to run correctly. As such, a user is recommended to
explicitly filter out duplicate literals from the assumptions list
before calling <a class="reference internal" href="#pysat.solvers.Solver.solve" title="pysat.solvers.Solver.solve"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve()</span></code></a>, <a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>,
<a class="reference internal" href="#pysat.solvers.Solver.propagate" title="pysat.solvers.Solver.propagate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">propagate()</span></code></a>, or <a class="reference internal" href="#pysat.solvers.Solver.enum_models" title="pysat.solvers.Solver.enum_models"><code class="xref py py-meth docutils literal notranslate"><span class="pre">enum_models()</span></code></a>.</p>
<p><strong>Note</strong> that since SIGINT handling and <a class="reference internal" href="#pysat.solvers.Solver.interrupt" title="pysat.solvers.Solver.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a> are not
configured to work <em>together</em> at this point, additional input
parameter <code class="docutils literal notranslate"><span class="pre">expect_interrupt</span></code> is assumed to be given, indicating
what kind of interruption may happen during the execution of
<a class="reference internal" href="#pysat.solvers.Solver.solve_limited" title="pysat.solvers.Solver.solve_limited"><code class="xref py py-meth docutils literal notranslate"><span class="pre">solve_limited()</span></code></a>: whether a SIGINT signal or internal
<a class="reference internal" href="#pysat.solvers.Solver.interrupt" title="pysat.solvers.Solver.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a>. By default, a SIGINT signal handling is
assumed. If <code class="docutils literal notranslate"><span class="pre">expect_interrupt</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> and eventually
a SIGINT is received, the behavior is <strong>undefined</strong>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>assumptions</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of assumption literals.</p></li>
<li><p><strong>expect_interrupt</strong> (<em>bool</em>) – whether <a class="reference internal" href="#pysat.solvers.Solver.interrupt" title="pysat.solvers.Solver.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a> will be called</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Boolean or <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p>Doing limited SAT calls can be of help if it is known that
<em>complete</em> SAT calls are too expensive. For instance, it can be
useful when minimizing unsatisfiable cores in MaxSAT (see
<code class="xref py py-meth docutils literal notranslate"><span class="pre">pysat.examples.RC2.minimize_core()</span></code> also shown below).</p>
<p>Also and besides supporting deterministic interruption based on
<a class="reference internal" href="#pysat.solvers.Solver.conf_budget" title="pysat.solvers.Solver.conf_budget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">conf_budget()</span></code></a> and/or <a class="reference internal" href="#pysat.solvers.Solver.prop_budget" title="pysat.solvers.Solver.prop_budget"><code class="xref py py-meth docutils literal notranslate"><span class="pre">prop_budget()</span></code></a>, limited SAT calls
support <em>deterministic</em> and <em>non-deterministic</em> interruption from
inside a Python script. See the <a class="reference internal" href="#pysat.solvers.Solver.interrupt" title="pysat.solvers.Solver.interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interrupt()</span></code></a> and
<a class="reference internal" href="#pysat.solvers.Solver.clear_interrupt" title="pysat.solvers.Solver.clear_interrupt"><code class="xref py py-meth docutils literal notranslate"><span class="pre">clear_interrupt()</span></code></a> methods for details.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="c1"># assume that a SAT oracle is set up to contain an unsatisfiable</span>
<span class="o">...</span> <span class="c1"># formula, and its core is stored in variable &quot;core&quot;</span>
<span class="n">oracle</span><span class="o">.</span><span class="n">conf_budget</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>  <span class="c1"># getting at most 1000 conflicts be call</span>

<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">core</span><span class="p">):</span>
    <span class="n">to_test</span> <span class="o">=</span> <span class="n">core</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">core</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):]</span>

    <span class="c1"># doing a limited call</span>
    <span class="k">if</span> <span class="n">oracle</span><span class="o">.</span><span class="n">solve_limited</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">to_test</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
        <span class="n">core</span> <span class="o">=</span> <span class="n">to_test</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># True or *unknown*</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.start_mode">
<span class="sig-name descname"><span class="pre">start_mode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.start_mode" title="Permalink to this definition">#</a></dt>
<dd><p>Set start mode: either warm or standard. Warm start mode can be
beneficial if one is interested in efficient model enumeration.</p>
<p>Note that warm start mode is disabled in the case of limited
solving with <em>“unknown”</em> outcomes. Moreover, warm start mode may
lead to unexpected results in case of assumption-based solving
with a <em>varying</em> list of assumption literals.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">model_count</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">formula</span><span class="p">,</span> <span class="n">vlimit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">solver</span><span class="p">,</span> <span class="n">bootstrap_with</span><span class="o">=</span><span class="n">formula</span><span class="p">,</span> <span class="n">use_timer</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="n">warm_start</span><span class="p">)</span> <span class="k">as</span> <span class="n">oracle</span><span class="p">:</span>
<span class="gp">... </span>        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>        <span class="k">while</span> <span class="n">oracle</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
<span class="gp">... </span>            <span class="n">model</span> <span class="o">=</span> <span class="n">oracle</span><span class="o">.</span><span class="n">get_model</span><span class="p">()</span>
<span class="gp">... </span>            <span class="k">if</span> <span class="n">vlimit</span><span class="p">:</span>
<span class="gp">... </span>                <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="p">[:</span><span class="n">vlimit</span><span class="p">]</span>
<span class="gp">... </span>            <span class="n">oracle</span><span class="o">.</span><span class="n">add_clause</span><span class="p">([</span><span class="o">-</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">model</span><span class="p">])</span>
<span class="gp">... </span>            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> models in </span><span class="si">{1:.4f}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">oracle</span><span class="o">.</span><span class="n">time_accum</span><span class="p">()))</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model_count</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">,</span> <span class="n">cnf</span><span class="p">,</span> <span class="n">vlimit</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">58651 models in 7.9903s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model_count</span><span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">,</span> <span class="n">cnf</span><span class="p">,</span> <span class="n">vlimit</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">warm_start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">58651 models in 0.3951s</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.supports_atmost">
<span class="sig-name descname"><span class="pre">supports_atmost</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.supports_atmost" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be called to determine whether the solver supports
native AtMostK (see <a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a>) constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p>A usage example is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;mc&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span><span class="o">.</span><span class="n">supports_atmost</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># there is support for AtMostK constraints in this solver</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.time">
<span class="sig-name descname"><span class="pre">time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.time" title="Permalink to this definition">#</a></dt>
<dd><p>Get the time spent when doing the last SAT call. <strong>Note</strong> that the
time is measured only if the <code class="docutils literal notranslate"><span class="pre">use_timer</span></code> argument was previously
set to <code class="docutils literal notranslate"><span class="pre">True</span></code> when creating the solver (see <a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> for
details).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">,</span> <span class="n">use_timer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">())</span>
<span class="go">False</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:.2f}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="go">150.16s</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.solvers.Solver.time_accum">
<span class="sig-name descname"><span class="pre">time_accum</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.solvers.Solver.time_accum" title="Permalink to this definition">#</a></dt>
<dd><p>Get the time spent for doing all SAT calls accumulated. <strong>Note</strong>
that the time is measured only if the <code class="docutils literal notranslate"><span class="pre">use_timer</span></code> argument was
previously set to <code class="docutils literal notranslate"><span class="pre">True</span></code> when creating the solver (see
<a class="reference internal" href="#pysat.solvers.Solver" title="pysat.solvers.Solver"><code class="xref py py-class docutils literal notranslate"><span class="pre">Solver</span></code></a> for details).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float.</p>
</dd>
</dl>
<p>Example usage:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.genhard</span> <span class="kn">import</span> <span class="n">PHP</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">PHP</span><span class="p">(</span><span class="n">nof_holes</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">,</span> <span class="n">use_timer</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:.2f}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="go">1.76s</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
<span class="go">False</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:.2f}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span>
<span class="go">113.58s</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{0:.2f}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">time_accum</span><span class="p">()))</span>
<span class="go">115.34s</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.solvers.SolverNames">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.solvers.</span></span><span class="sig-name descname"><span class="pre">SolverNames</span></span><a class="headerlink" href="#pysat.solvers.SolverNames" title="Permalink to this definition">#</a></dt>
<dd><p>This class serves to determine the solver requested by a user given a
string name. This allows for using several possible names for
specifying a solver.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cadical103</span>  <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cd&#39;</span><span class="p">,</span> <span class="s1">&#39;cd103&#39;</span><span class="p">,</span> <span class="s1">&#39;cdl&#39;</span><span class="p">,</span> <span class="s1">&#39;cdl103&#39;</span><span class="p">,</span> <span class="s1">&#39;cadical103&#39;</span><span class="p">)</span>
<span class="n">cadical153</span>  <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cd15&#39;</span><span class="p">,</span> <span class="s1">&#39;cd153&#39;</span><span class="p">,</span> <span class="s1">&#39;cdl15&#39;</span><span class="p">,</span> <span class="s1">&#39;cdl153&#39;</span><span class="p">,</span> <span class="s1">&#39;cadical153&#39;</span><span class="p">)</span>
<span class="n">cryptosat</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;cms&#39;</span><span class="p">,</span> <span class="s1">&#39;cms5&#39;</span><span class="p">,</span> <span class="s1">&#39;crypto&#39;</span><span class="p">,</span> <span class="s1">&#39;crypto5&#39;</span><span class="p">,</span> <span class="s1">&#39;cryptominisat&#39;</span><span class="p">,</span> <span class="s1">&#39;cryptominisat5&#39;</span><span class="p">)</span>
<span class="n">gluecard3</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;gc3&#39;</span><span class="p">,</span> <span class="s1">&#39;gc30&#39;</span><span class="p">,</span> <span class="s1">&#39;gluecard3&#39;</span><span class="p">,</span> <span class="s1">&#39;gluecard30&#39;</span><span class="p">)</span>
<span class="n">gluecard41</span>  <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;gc4&#39;</span><span class="p">,</span> <span class="s1">&#39;gc41&#39;</span><span class="p">,</span> <span class="s1">&#39;gluecard4&#39;</span><span class="p">,</span> <span class="s1">&#39;gluecard41&#39;</span><span class="p">)</span>
<span class="n">glucose3</span>    <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;g3&#39;</span><span class="p">,</span> <span class="s1">&#39;g30&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose3&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose30&#39;</span><span class="p">)</span>
<span class="n">glucose4</span>    <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;g4&#39;</span><span class="p">,</span> <span class="s1">&#39;g41&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose4&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose41&#39;</span><span class="p">)</span>
<span class="n">glucose42</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;g42&#39;</span><span class="p">,</span> <span class="s1">&#39;g421&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose42&#39;</span><span class="p">,</span> <span class="s1">&#39;glucose421&#39;</span><span class="p">)</span>
<span class="n">lingeling</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;lgl&#39;</span><span class="p">,</span> <span class="s1">&#39;lingeling&#39;</span><span class="p">)</span>
<span class="n">maplechrono</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mcb&#39;</span><span class="p">,</span> <span class="s1">&#39;chrono&#39;</span><span class="p">,</span> <span class="s1">&#39;maplechrono&#39;</span><span class="p">)</span>
<span class="n">maplecm</span>     <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mcm&#39;</span><span class="p">,</span> <span class="s1">&#39;maplecm&#39;</span><span class="p">)</span>
<span class="n">maplesat</span>    <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mpl&#39;</span><span class="p">,</span> <span class="s1">&#39;maple&#39;</span><span class="p">,</span> <span class="s1">&#39;maplesat&#39;</span><span class="p">)</span>
<span class="n">mergesat3</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mg3&#39;</span><span class="p">,</span> <span class="s1">&#39;mgs3&#39;</span><span class="p">,</span> <span class="s1">&#39;mergesat3&#39;</span><span class="p">,</span> <span class="s1">&#39;mergesat30&#39;</span><span class="p">)</span>
<span class="n">minicard</span>    <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mc&#39;</span><span class="p">,</span> <span class="s1">&#39;mcard&#39;</span><span class="p">,</span> <span class="s1">&#39;minicard&#39;</span><span class="p">)</span>
<span class="n">minisat22</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;m22&#39;</span><span class="p">,</span> <span class="s1">&#39;msat22&#39;</span><span class="p">,</span> <span class="s1">&#39;minisat22&#39;</span><span class="p">)</span>
<span class="n">minisatgh</span>   <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mgh&#39;</span><span class="p">,</span> <span class="s1">&#39;msat-gh&#39;</span><span class="p">,</span> <span class="s1">&#39;minisat-gh&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>As a result, in order to select Glucose3, a user can specify the
solver’s name: either <code class="docutils literal notranslate"><span class="pre">'g3'</span></code>, <code class="docutils literal notranslate"><span class="pre">'g30'</span></code>, <code class="docutils literal notranslate"><span class="pre">'glucose3'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'glucose30'</span></code>. <em>Note that the capitalized versions of these names
are also allowed</em>.</p>
</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="process.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Formula processing (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.process</span></code>)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="examples/fm.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Fu&amp;Malik MaxSAT algorithm (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.fm</span></code>)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018-2024, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>