
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>LBX-like MCS enumerator (pysat.examples.lbx) &#8212; PySAT 0.1.8.dev13 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="LSU algorithm for MaxSAT (pysat.examples.lsu)" href="lsu.html" />
    <link rel="prev" title="Minimum/minimal hitting set solver (pysat.examples.hitman)" href="hitman.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="https://pysathq.github.io">
  <img src="../../_static/logo-dark.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <!-- This will display the version of the docs -->
<a href=https://pysathq.github.io/docs/html/index.html><strong>PySAT Documentation (version 0.1.8.dev13)</strong></a>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pysathq.github.io/docs/pysat.pdf" rel="noopener" target="_blank" title="PDF"><span><i class="fas fa-file"></i></span>
            <label class="sr-only">PDF</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat/issues" rel="noopener" target="_blank" title="Issue tracker"><span><i class="fas fa-bug"></i></span>
            <label class="sr-only">Issue tracker</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-description">
   Module description
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-details">
   Module details
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-examples.lbx">
<span id="lbx-like-mcs-enumerator-pysat-examples-lbx"></span><h1>LBX-like MCS enumerator (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.lbx</span></code>)<a class="headerlink" href="#module-examples.lbx" title="Permalink to this headline">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">#</a></h2>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#examples.lbx.LBX" title="examples.lbx.LBX"><code class="xref py py-obj docutils literal notranslate"><span class="pre">LBX</span></code></a></p></td>
<td><p>LBX-like algorithm for computing MCSes.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">#</a></h2>
<p>This module implements a prototype of the LBX algorithm for the computation
of a <em>minimal correction subset</em> (MCS) and/or MCS enumeration. The LBX
abbreviation stands for <em>literal-based MCS extraction</em> algorithm, which was
proposed in <a class="footnote-reference brackets" href="#id3" id="id1">1</a>. Note that this prototype does not follow the original
low-level implementation of the corresponding MCS extractor available
<a class="reference external" href="https://reason.di.fc.ul.pt/wiki/doku.php?id=lbx">online</a> (compared to
our prototype, the low-level implementation has a number of additional
heuristics used). However, it implements the LBX algorithm for partial
MaxSAT formulas, as described in <a class="footnote-reference brackets" href="#id3" id="id2">1</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id3"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id4">3</a>,<a href="#id5">4</a>)</span></dt>
<dd><p>Carlos Mencia, Alessandro Previti, Joao Marques-Silva.
<em>Literal-Based MCS Extraction</em>. IJCAI 2015. pp. 1973-1979</p>
</dd>
</dl>
<p>The implementation can be used as an executable (the list of available
command-line options can be shown using <code class="docutils literal notranslate"><span class="pre">lbx.py</span> <span class="pre">-h</span></code>) in the following
way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ xzcat formula.wcnf.xz
p wcnf 3 6 4
1 1 0
1 2 0
1 3 0
4 -1 -2 0
4 -1 -3 0
4 -2 -3 0

$ lbx.py -d -e all -s glucose3 -vv formula.wcnf.xz
c MCS: 1 3 0
c cost: 2
c MCS: 2 3 0
c cost: 2
c MCS: 1 2 0
c cost: 2
c oracle time: 0.0002
</pre></div>
</div>
<p>Alternatively, the algorithm can be accessed and invoked through the
standard <code class="docutils literal notranslate"><span class="pre">import</span></code> interface of Python, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.lbx</span> <span class="kn">import</span> <span class="n">LBX</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;formula.wcnf.xz&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lbx</span> <span class="o">=</span> <span class="n">LBX</span><span class="p">(</span><span class="n">wcnf</span><span class="p">,</span> <span class="n">use_cld</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="s1">&#39;g3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mcs</span> <span class="ow">in</span> <span class="n">lbx</span><span class="o">.</span><span class="n">enumerate</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">lbx</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">mcs</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">mcs</span><span class="p">)</span>
<span class="go">[1, 3]</span>
<span class="go">[2, 3]</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="examples.lbx.LBX">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">examples.lbx.</span></span><span class="sig-name descname"><span class="pre">LBX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_cld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'m22'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_timer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX" title="Permalink to this definition">#</a></dt>
<dd><p>LBX-like algorithm for computing MCSes. Given an unsatisfiable partial
CNF formula, i.e. formula in the <a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> format, this class can
be used to compute a given number of MCSes of the formula. The
implementation follows the LBX algorithm description in <a class="footnote-reference brackets" href="#id3" id="id4">1</a>. It can
use any SAT solver available in PySAT. Additionally, the “clause
<span class="math notranslate nohighlight">\(D\)</span>” heuristic can be used when enumerating MCSes.</p>
<p>The default SAT solver to use is <code class="docutils literal notranslate"><span class="pre">m22</span></code> (see <a class="reference internal" href="../solvers.html#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-class docutils literal notranslate"><span class="pre">SolverNames</span></code></a>).
The “clause <span class="math notranslate nohighlight">\(D\)</span>” heuristic is disabled by default, i.e.
<code class="docutils literal notranslate"><span class="pre">use_cld</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>. Internal SAT solver’s timer is also
disabled by default, i.e. <code class="docutils literal notranslate"><span class="pre">use_timer</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>) – unsatisfiable partial CNF formula</p></li>
<li><p><strong>use_cld</strong> (<em>bool</em>) – whether or not to use “clause <span class="math notranslate nohighlight">\(D\)</span>”</p></li>
<li><p><strong>solver_name</strong> (<em>str</em>) – SAT oracle name</p></li>
<li><p><strong>use_timer</strong> (<em>bool</em>) – whether or not to use SAT solver’s timer</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX._compute">
<span class="sig-name descname"><span class="pre">_compute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX._compute" title="Permalink to this definition">#</a></dt>
<dd><p>The main method of the class, which computes an MCS given its
over-approximation. The over-approximation is defined by a model
for the hard part of the formula obtained in <a class="reference internal" href="#examples.lbx.LBX.compute" title="examples.lbx.LBX.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute()</span></code></a>.</p>
<p>The method is essentially a simple loop going over all literals
unsatisfied by the previous model, i.e. the literals of
<code class="docutils literal notranslate"><span class="pre">self.setd</span></code> and checking which literals can be satisfied. This
process can be seen a refinement of the over-approximation of the
MCS. The algorithm follows the pseudo-code of the LBX algorithm
presented in <a class="footnote-reference brackets" href="#id3" id="id5">1</a>.</p>
<p>Additionally, if <a class="reference internal" href="#examples.lbx.LBX" title="examples.lbx.LBX"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBX</span></code></a> was constructed with the requirement
to make “clause <span class="math notranslate nohighlight">\(D\)</span>” calls, the method calls
<a class="reference internal" href="#examples.lbx.LBX.do_cld_check" title="examples.lbx.LBX.do_cld_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_cld_check()</span></code></a> at every iteration of the loop using the
literals of <code class="docutils literal notranslate"><span class="pre">self.setd</span></code> not yet checked, as the contents of
“clause <span class="math notranslate nohighlight">\(D\)</span>”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX._filter_satisfied">
<span class="sig-name descname"><span class="pre">_filter_satisfied</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">update_setd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX._filter_satisfied" title="Permalink to this definition">#</a></dt>
<dd><p>This method extracts a model provided by the previous call to a SAT
oracle and iterates over all soft clauses checking if each of is
satisfied by the model. Satisfied clauses are marked accordingly
while the literals of the unsatisfied clauses are kept in a list
called <code class="docutils literal notranslate"><span class="pre">setd</span></code>, which is then used to refine the correction set
(see <a class="reference internal" href="#examples.lbx.LBX._compute" title="examples.lbx.LBX._compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">_compute()</span></code></a>, and <a class="reference internal" href="#examples.lbx.LBX.do_cld_check" title="examples.lbx.LBX.do_cld_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_cld_check()</span></code></a>).</p>
<p>Optional Boolean parameter <code class="docutils literal notranslate"><span class="pre">update_setd</span></code> enforces the method to
update variable <code class="docutils literal notranslate"><span class="pre">self.setd</span></code>. If this parameter is set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, the method only updates the list of satisfied clauses,
which is an under-approximation of a <em>maximal satisfiable subset</em>
(MSS).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>update_setd</strong> (<em>bool</em>) – whether or not to update setd</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX._map_extlit">
<span class="sig-name descname"><span class="pre">_map_extlit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX._map_extlit" title="Permalink to this definition">#</a></dt>
<dd><p>Map an external variable to an internal one if necessary.</p>
<p>This method is used when new clauses are added to the formula
incrementally, which may result in introducing new variables
clashing with the previously used <em>clause selectors</em>. The method
makes sure no clash occurs, i.e. it maps the original variables
used in the new problem clauses to the newly introduced auxiliary
variables (see <a class="reference internal" href="#examples.lbx.LBX.add_clause" title="examples.lbx.LBX.add_clause"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_clause()</span></code></a>).</p>
<p>Given an integer literal, a fresh literal is returned. The returned
integer has the same sign as the input literal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>l</strong> (<em>int</em>) – literal to map</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX._satisfied">
<span class="sig-name descname"><span class="pre">_satisfied</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX._satisfied" title="Permalink to this definition">#</a></dt>
<dd><p>Given a clause (as an iterable of integers) and an assignment (as a
list of integers), this method checks whether or not the assignment
satisfies the clause. This is done by a simple clause traversal.
The method is invoked from <a class="reference internal" href="#examples.lbx.LBX._filter_satisfied" title="examples.lbx.LBX._filter_satisfied"><code class="xref py py-func docutils literal notranslate"><span class="pre">_filter_satisfied()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cl</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a clause to check</p></li>
<li><p><strong>model</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – an assignment</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.add_clause">
<span class="sig-name descname"><span class="pre">add_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">soft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.add_clause" title="Permalink to this definition">#</a></dt>
<dd><p>The method for adding a new hard of soft clause to the problem
formula. Although the input formula is to be specified as an
argument of the constructor of <a class="reference internal" href="#examples.lbx.LBX" title="examples.lbx.LBX"><code class="xref py py-class docutils literal notranslate"><span class="pre">LBX</span></code></a>, adding clauses may be
helpful when <em>enumerating</em> MCSes of the formula. This way, the
clauses are added incrementally, i.e. <em>on the fly</em>.</p>
<p>The clause to add can be any iterable over integer literals. The
additional Boolean parameter <code class="docutils literal notranslate"><span class="pre">soft</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
meaning the the clause being added is soft (note that parameter
<code class="docutils literal notranslate"><span class="pre">soft</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default).</p>
<p>Also note that besides pure clauses, the method can also expect
native cardinality constraints represented as a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span>
<span class="pre">bound)</span></code>. Only hard cardinality constraints can be added.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a clause to add</p></li>
<li><p><strong>soft</strong> (<em>bool</em>) – whether or not the clause is soft</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.block">
<span class="sig-name descname"><span class="pre">block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mcs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.block" title="Permalink to this definition">#</a></dt>
<dd><p>Block a (previously computed) MCS. The MCS should be given as an
iterable of integers. Note that this method is not automatically
invoked from <a class="reference internal" href="#examples.lbx.LBX.enumerate" title="examples.lbx.LBX.enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> because a user may want to block
some of the MCSes conditionally depending on the needs. For
example, one may want to compute disjoint MCSes only in which case
this standard blocking is not appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mcs</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – an MCS to block</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.compute" title="Permalink to this definition">#</a></dt>
<dd><p>Compute and return one solution. This method checks whether the
hard part of the formula is satisfiable, i.e. an MCS can be
extracted. If the formula is satisfiable, the model computed by the
SAT call is used as an <em>over-approximation</em> of the MCS in the
method <a class="reference internal" href="#examples.lbx.LBX._compute" title="examples.lbx.LBX._compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">_compute()</span></code></a> invoked here, which implements the LBX
algorithm.</p>
<p>An MCS is reported as a list of integers, each representing a soft
clause index (the smallest index is <code class="docutils literal notranslate"><span class="pre">1</span></code>).</p>
<p>An optional input parameter is <code class="docutils literal notranslate"><span class="pre">enable</span></code>, which represents a
sequence (normally a list) of soft clause indices that a user
would prefer to enable/satisfy. Note that this may result in an
unsatisfiable oracle call, in which case <code class="docutils literal notranslate"><span class="pre">None</span></code> will be reported
as solution. Also, the smallest clause index is assumed to be
<code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enable</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a sequence of clause ids to enable</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.delete" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit destructor of the internal SAT oracle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.do_cld_check">
<span class="sig-name descname"><span class="pre">do_cld_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cld</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.do_cld_check" title="Permalink to this definition">#</a></dt>
<dd><p>Do the “clause <span class="math notranslate nohighlight">\(D\)</span>” check. This method receives a list of
literals, which serves a “clause <span class="math notranslate nohighlight">\(D\)</span>” <a class="footnote-reference brackets" href="#id7" id="id6">2</a>, and checks
whether the formula conjoined with <span class="math notranslate nohighlight">\(D\)</span> is satisfiable.</p>
<dl class="footnote brackets">
<dt class="label" id="id7"><span class="brackets"><a class="fn-backref" href="#id6">2</a></span></dt>
<dd><p>Joao Marques-Silva, Federico Heras, Mikolas Janota,
Alessandro Previti, Anton Belov. <em>On Computing Minimal
Correction Subsets</em>. IJCAI 2013. pp. 615-622</p>
</dd>
</dl>
<p>If clause <span class="math notranslate nohighlight">\(D\)</span> cannot be satisfied together with the formula,
then negations of all of its literals are backbones of the formula
and the LBX algorithm can stop. Otherwise, the literals satisfied
by the new model refine the MCS further.</p>
<p>Every time the method is called, a new fresh selector variable
<span class="math notranslate nohighlight">\(s\)</span> is introduced, which augments the current clause
<span class="math notranslate nohighlight">\(D\)</span>. The SAT oracle then checks if clause <span class="math notranslate nohighlight">\((D \vee
\neg{s})\)</span> can be satisfied together with the internal formula.
The <span class="math notranslate nohighlight">\(D\)</span> clause is then disabled by adding a hard clause
<span class="math notranslate nohighlight">\((\neg{s})\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cld</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – clause <span class="math notranslate nohighlight">\(D\)</span> to check</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.enumerate">
<span class="sig-name descname"><span class="pre">enumerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.enumerate" title="Permalink to this definition">#</a></dt>
<dd><p>This method iterates through MCSes enumerating them until the
formula has no more MCSes. The method iteratively invokes
<a class="reference internal" href="#examples.lbx.LBX.compute" title="examples.lbx.LBX.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute()</span></code></a>. Note that the method does not block the MCSes
computed - this should be explicitly done by a user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.lbx.LBX.oracle_time">
<span class="sig-name descname"><span class="pre">oracle_time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.lbx.LBX.oracle_time" title="Permalink to this definition">#</a></dt>
<dd><p>Report the total SAT solving time.</p>
</dd></dl>

</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="hitman.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Minimum/minimal hitting set solver (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.hitman</span></code>)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="lsu.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">LSU algorithm for MaxSAT (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.lsu</span></code>)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018-2022, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>