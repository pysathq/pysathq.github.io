
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>CLD-like MCS enumerator (pysat.examples.mcsls) &#8212; PySAT 0.1.8.dev5 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="An iterative model enumerator (pysat.examples.models)" href="models.html" />
    <link rel="prev" title="LSU algorithm for MaxSAT (pysat.examples.lsu)" href="lsu.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="https://pysathq.github.io">
  <img src="../../_static/logo-dark.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <!-- This will display the version of the docs -->
<a href=https://pysathq.github.io/docs/html/index.html><strong>PySAT Documentation (version 0.1.8.dev5)</strong></a>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pysathq.github.io/docs/pysat.pdf" rel="noopener" target="_blank" title="PDF"><span><i class="fas fa-file"></i></span>
            <label class="sr-only">PDF</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat/issues" rel="noopener" target="_blank" title="Issue tracker"><span><i class="fas fa-bug"></i></span>
            <label class="sr-only">Issue tracker</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-description">
   Module description
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-details">
   Module details
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-examples.mcsls">
<span id="cld-like-mcs-enumerator-pysat-examples-mcsls"></span><h1>CLD-like MCS enumerator (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.mcsls</span></code>)<a class="headerlink" href="#module-examples.mcsls" title="Permalink to this headline">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">#</a></h2>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#examples.mcsls.MCSls" title="examples.mcsls.MCSls"><code class="xref py py-obj docutils literal notranslate"><span class="pre">MCSls</span></code></a></p></td>
<td><p>Algorithm BLS for computing MCSes, augmented with &quot;clause <span class="math notranslate nohighlight">\(D\)</span>&quot; calls.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">#</a></h2>
<p>This module implements a prototype of a BLS- and CLD-like algorithm for the
computation of a <em>minimal correction subset</em> (MCS) and/or MCS enumeration.
More concretely, the implementation follows the <em>basic linear search</em> (BLS)
for MCS exctraction augmented with <em>clause D</em> (CLD) oracle calls. As a
result, the algorithm is not an implementation of the BLS or CLD algorithms
as described in <a class="footnote-reference brackets" href="#id2" id="id1">1</a> but a mixture of both. Note that the corresponding
original low-level implementations of both can be found <a class="reference external" href="https://reason.di.fc.ul.pt/wiki/doku.php?id=mcsls">online</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id3">2</a>,<a href="#id4">3</a>,<a href="#id5">4</a>)</span></dt>
<dd><p>Joao Marques-Silva, Federico Heras, Mikolas Janota, Alessandro
Previti, Anton Belov. <em>On Computing Minimal Correction Subsets</em>.
IJCAI 2013. pp.  615-622</p>
</dd>
</dl>
<p>The implementation can be used as an executable (the list of available
command-line options can be shown using <code class="docutils literal notranslate"><span class="pre">mcsls.py</span> <span class="pre">-h</span></code>) in the following
way:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ xzcat formula.wcnf.xz
p wcnf 3 6 4
1 1 0
1 2 0
1 3 0
4 -1 -2 0
4 -1 -3 0
4 -2 -3 0

$ mcsls.py -d -e all -s glucose3 -vv formula.wcnf.xz
c MCS: 1 3 0
c cost: 2
c MCS: 2 3 0
c cost: 2
c MCS: 1 2 0
c cost: 2
c oracle time: 0.0002
</pre></div>
</div>
<p>Alternatively, the algorithm can be accessed and invoked through the
standard <code class="docutils literal notranslate"><span class="pre">import</span></code> interface of Python, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.examples.mcsls</span> <span class="kn">import</span> <span class="n">MCSls</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;formula.wcnf.xz&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mcsls</span> <span class="o">=</span> <span class="n">MCSls</span><span class="p">(</span><span class="n">wcnf</span><span class="p">,</span> <span class="n">use_cld</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">solver_name</span><span class="o">=</span><span class="s1">&#39;g3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">mcs</span> <span class="ow">in</span> <span class="n">mcsls</span><span class="o">.</span><span class="n">enumerate</span><span class="p">():</span>
<span class="gp">... </span>    <span class="n">mcsls</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">mcs</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">mcs</span><span class="p">)</span>
<span class="go">[1, 3]</span>
<span class="go">[2, 3]</span>
<span class="go">[1, 2]</span>
</pre></div>
</div>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="examples.mcsls.MCSls">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">examples.mcsls.</span></span><span class="sig-name descname"><span class="pre">MCSls</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_cld</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">solver_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'m22'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_timer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls" title="Permalink to this definition">#</a></dt>
<dd><p>Algorithm BLS for computing MCSes, augmented with “clause <span class="math notranslate nohighlight">\(D\)</span>”
calls. Given an unsatisfiable partial CNF formula, i.e.  formula in the
<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> format, this class can be used to compute a given number
of MCSes of the formula. The implementation follows the description of
the basic linear search (BLS) algorithm description in <a class="footnote-reference brackets" href="#id2" id="id3">1</a>. It can use
any SAT solver available in PySAT. Additionally, the “clause <span class="math notranslate nohighlight">\(D\)</span>”
heuristic can be used when enumerating MCSes.</p>
<p>The default SAT solver to use is <code class="docutils literal notranslate"><span class="pre">m22</span></code> (see <a class="reference internal" href="../solvers.html#pysat.solvers.SolverNames" title="pysat.solvers.SolverNames"><code class="xref py py-class docutils literal notranslate"><span class="pre">SolverNames</span></code></a>).
The “clause <span class="math notranslate nohighlight">\(D\)</span>” heuristic is disabled by default, i.e.
<code class="docutils literal notranslate"><span class="pre">use_cld</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>. Internal SAT solver’s timer is also
disabled by default, i.e. <code class="docutils literal notranslate"><span class="pre">use_timer</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>formula</strong> (<a class="reference internal" href="../formula.html#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>) – unsatisfiable partial CNF formula</p></li>
<li><p><strong>use_cld</strong> (<em>bool</em>) – whether or not to use “clause <span class="math notranslate nohighlight">\(D\)</span>”</p></li>
<li><p><strong>solver_name</strong> (<em>str</em>) – SAT oracle name</p></li>
<li><p><strong>use_timer</strong> (<em>bool</em>) – whether or not to use SAT solver’s timer</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls._compute">
<span class="sig-name descname"><span class="pre">_compute</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls._compute" title="Permalink to this definition">#</a></dt>
<dd><p>The main method of the class, which computes an MCS given its
over-approximation. The over-approximation is defined by a model
for the hard part of the formula obtained in <a class="reference internal" href="#examples.mcsls.MCSls._overapprox" title="examples.mcsls.MCSls._overapprox"><code class="xref py py-func docutils literal notranslate"><span class="pre">_overapprox()</span></code></a>
(the corresponding oracle is made in <a class="reference internal" href="#examples.mcsls.MCSls.compute" title="examples.mcsls.MCSls.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute()</span></code></a>).</p>
<p>The method is essentially a simple loop going over all literals
unsatisfied by the previous model, i.e. the literals of
<code class="docutils literal notranslate"><span class="pre">self.setd</span></code> and checking which literals can be satisfied. This
process can be seen a refinement of the over-approximation of the
MCS. The algorithm follows the pseudo-code of the BLS algorithm
presented in <a class="footnote-reference brackets" href="#id2" id="id4">1</a>.</p>
<p>Additionally, if <a class="reference internal" href="#examples.mcsls.MCSls" title="examples.mcsls.MCSls"><code class="xref py py-class docutils literal notranslate"><span class="pre">MCSls</span></code></a> was constructed with the
requirement to make “clause <span class="math notranslate nohighlight">\(D\)</span>” calls, the method calls
<a class="reference internal" href="#examples.mcsls.MCSls.do_cld_check" title="examples.mcsls.MCSls.do_cld_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">do_cld_check()</span></code></a> at every iteration of the loop using the
literals of <code class="docutils literal notranslate"><span class="pre">self.setd</span></code> not yet checked, as the contents of
“clause <span class="math notranslate nohighlight">\(D\)</span>”.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls._map_extlit">
<span class="sig-name descname"><span class="pre">_map_extlit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">l</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls._map_extlit" title="Permalink to this definition">#</a></dt>
<dd><p>Map an external variable to an internal one if necessary.</p>
<p>This method is used when new clauses are added to the formula
incrementally, which may result in introducing new variables
clashing with the previously used <em>clause selectors</em>. The method
makes sure no clash occurs, i.e. it maps the original variables
used in the new problem clauses to the newly introduced auxiliary
variables (see <a class="reference internal" href="#examples.mcsls.MCSls.add_clause" title="examples.mcsls.MCSls.add_clause"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_clause()</span></code></a>).</p>
<p>Given an integer literal, a fresh literal is returned. The returned
integer has the same sign as the input literal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>l</strong> (<em>int</em>) – literal to map</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls._overapprox">
<span class="sig-name descname"><span class="pre">_overapprox</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls._overapprox" title="Permalink to this definition">#</a></dt>
<dd><p>The method extracts a model corresponding to an over-approximation
of an MCS, i.e. it is the model of the hard part of the formula
(the corresponding oracle call is made in <a class="reference internal" href="#examples.mcsls.MCSls.compute" title="examples.mcsls.MCSls.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute()</span></code></a>).</p>
<p>Here, the set of selectors is divided into two parts:
<code class="docutils literal notranslate"><span class="pre">self.ss_assumps</span></code>, which is an under-approximation of an MSS
(maximal satisfiable subset) and <code class="docutils literal notranslate"><span class="pre">self.setd</span></code>, which is an
over-approximation of the target MCS. Both will be further refined
in <a class="reference internal" href="#examples.mcsls.MCSls._compute" title="examples.mcsls.MCSls._compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">_compute()</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.add_clause">
<span class="sig-name descname"><span class="pre">add_clause</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">soft</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.add_clause" title="Permalink to this definition">#</a></dt>
<dd><p>The method for adding a new hard of soft clause to the problem
formula. Although the input formula is to be specified as an
argument of the constructor of <a class="reference internal" href="#examples.mcsls.MCSls" title="examples.mcsls.MCSls"><code class="xref py py-class docutils literal notranslate"><span class="pre">MCSls</span></code></a>, adding clauses may
be helpful when <em>enumerating</em> MCSes of the formula. This way, the
clauses are added incrementally, i.e. <em>on the fly</em>.</p>
<p>The clause to add can be any iterable over integer literals. The
additional Boolean parameter <code class="docutils literal notranslate"><span class="pre">soft</span></code> can be set to <code class="docutils literal notranslate"><span class="pre">True</span></code>
meaning the the clause being added is soft (note that parameter
<code class="docutils literal notranslate"><span class="pre">soft</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default).</p>
<p>Also note that besides pure clauses, the method can also expect
native cardinality constraints represented as a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span>
<span class="pre">bound)</span></code>. Only hard cardinality constraints can be added.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a clause to add</p></li>
<li><p><strong>soft</strong> (<em>bool</em>) – whether or not the clause is soft</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.block">
<span class="sig-name descname"><span class="pre">block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mcs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.block" title="Permalink to this definition">#</a></dt>
<dd><p>Block a (previously computed) MCS. The MCS should be given as an
iterable of integers. Note that this method is not automatically
invoked from <a class="reference internal" href="#examples.mcsls.MCSls.enumerate" title="examples.mcsls.MCSls.enumerate"><code class="xref py py-func docutils literal notranslate"><span class="pre">enumerate()</span></code></a> because a user may want to block
some of the MCSes conditionally depending on the needs. For
example, one may want to compute disjoint MCSes only in which case
this standard blocking is not appropriate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>mcs</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – an MCS to block</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.compute">
<span class="sig-name descname"><span class="pre">compute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">enable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.compute" title="Permalink to this definition">#</a></dt>
<dd><p>Compute and return one solution. This method checks whether the
hard part of the formula is satisfiable, i.e. an MCS can be
extracted. If the formula is satisfiable, the model computed by the
SAT call is used as an <em>over-approximation</em> of the MCS in the
method <a class="reference internal" href="#examples.mcsls.MCSls._compute" title="examples.mcsls.MCSls._compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">_compute()</span></code></a> invoked here, which implements the BLS</p>
<p>An MCS is reported as a list of integers, each representing a soft
clause index (the smallest index is <code class="docutils literal notranslate"><span class="pre">1</span></code>).</p>
<p>An optional input parameter is <code class="docutils literal notranslate"><span class="pre">enable</span></code>, which represents a
sequence (normally a list) of soft clause indices that a user
would prefer to enable/satisfy. Note that this may result in an
unsatisfiable oracle call, in which case <code class="docutils literal notranslate"><span class="pre">None</span></code> will be reported
as solution. Also, the smallest clause index is assumed to be
<code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>enable</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a sequence of clause ids to enable</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list(int)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.delete" title="Permalink to this definition">#</a></dt>
<dd><p>Explicit destructor of the internal SAT oracle.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.do_cld_check">
<span class="sig-name descname"><span class="pre">do_cld_check</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cld</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.do_cld_check" title="Permalink to this definition">#</a></dt>
<dd><p>Do the “clause <span class="math notranslate nohighlight">\(D\)</span>” check. This method receives a list of
literals, which serves a “clause <span class="math notranslate nohighlight">\(D\)</span>” <a class="footnote-reference brackets" href="#id2" id="id5">1</a>, and checks
whether the formula conjoined with <span class="math notranslate nohighlight">\(D\)</span> is satisfiable.</p>
<p>If clause <span class="math notranslate nohighlight">\(D\)</span> cannot be satisfied together with the formula,
then negations of all of its literals are backbones of the formula
and the MCSls algorithm can stop. Otherwise, the literals satisfied
by the new model refine the MCS further.</p>
<p>Every time the method is called, a new fresh selector variable
<span class="math notranslate nohighlight">\(s\)</span> is introduced, which augments the current clause
<span class="math notranslate nohighlight">\(D\)</span>. The SAT oracle then checks if clause <span class="math notranslate nohighlight">\((D \vee
\neg{s})\)</span> can be satisfied together with the internal formula.
The <span class="math notranslate nohighlight">\(D\)</span> clause is then disabled by adding a hard clause
<span class="math notranslate nohighlight">\((\neg{s})\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cld</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – clause <span class="math notranslate nohighlight">\(D\)</span> to check</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.enumerate">
<span class="sig-name descname"><span class="pre">enumerate</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.enumerate" title="Permalink to this definition">#</a></dt>
<dd><p>This method iterates through MCSes enumerating them until the
formula has no more MCSes. The method iteratively invokes
<a class="reference internal" href="#examples.mcsls.MCSls.compute" title="examples.mcsls.MCSls.compute"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute()</span></code></a>. Note that the method does not block the MCSes
computed - this should be explicitly done by a user.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="examples.mcsls.MCSls.oracle_time">
<span class="sig-name descname"><span class="pre">oracle_time</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#examples.mcsls.MCSls.oracle_time" title="Permalink to this definition">#</a></dt>
<dd><p>Report the total SAT solving time.</p>
</dd></dl>

</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="lsu.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">LSU algorithm for MaxSAT (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.lsu</span></code>)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="models.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">An iterative model enumerator (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.examples.models</span></code>)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018-2022, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>