
<!DOCTYPE html>


<html lang="en" data-content_root="../" data-theme="auto">

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Boolean formula manipulation (pysat.formula) &#8212; PySAT 1.8.dev19 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "auto";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "auto";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
  
  <!-- So that users can add custom icons -->
  <script src="../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../_static/documentation_options.js?v=d17f4257"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'api/formula';</script>
    <link rel="icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="External engines (pysat.engines)" href="engines.html" />
    <link rel="prev" title="Cardinality encodings (pysat.card)" href="card.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="auto">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  

<a class="navbar-brand logo" href="https://pysathq.github.io">
  
  
  
  
  
    
    
      
    
    
    <img src="../_static/logo-dark.svg" class="logo__image only-light" alt="PySAT 1.8.dev19 documentation - Home"/>
    <img src="../_static/logo-dark.svg" class="logo__image only-dark pst-js-only" alt="PySAT 1.8.dev19 documentation - Home"/>
  
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item"><!-- This will display the version of the docs -->
<a href=><strong>PySAT Documentation (version 1.8.dev19)</strong></a></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pysathq/pysat" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pysathq.github.io/docs/pysat.pdf" title="PDF" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-file fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PDF</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pysathq/pysat/issues" title="Issue tracker" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-bug fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Issue tracker</span></a>
        </li>
</ul></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
    <button class="pst-navbar-icon sidebar-toggle secondary-toggle" aria-label="On this page">
      <span class="fa-solid fa-outdent"></span>
    </button>
  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item"><!-- This will display the version of the docs -->
<a href=><strong>PySAT Documentation (version 1.8.dev19)</strong></a></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pysathq/pysat" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://pysathq.github.io/docs/pysat.pdf" title="PDF" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-file fa-lg" aria-hidden="true"></i>
            <span class="sr-only">PDF</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pysathq/pysat/issues" title="Issue tracker" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fas fa-bug fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Issue tracker</span></a>
        </li>
</ul></div>
        
      </div>
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
        <div class="sidebar-primary-item">
<nav class="bd-docs-nav bd-links"
     aria-label="Section Navigation">
  <p class="bd-links__title" role="heading" aria-level="1">Section Navigation</p>
  <div class="bd-toc-item navbar-nav"></div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">Boolean formula manipulation (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code>)</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <section id="module-pysat.formula">
<span id="boolean-formula-manipulation-pysat-formula"></span><h1>Boolean formula manipulation (<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a>)<a class="headerlink" href="#module-pysat.formula" title="Link to this heading">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="autosummary longtable table autosummary">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDPool</span></code></a></p></td>
<td><p>A simple manager of variable IDs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Formula</span></code></a></p></td>
<td><p>Abstract formula class.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.Atom" title="pysat.formula.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a></p></td>
<td><p>Atomic formula, i.e. a variable or constant.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.And" title="pysat.formula.And"><code class="xref py py-obj docutils literal notranslate"><span class="pre">And</span></code></a></p></td>
<td><p>Conjunction.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.Or" title="pysat.formula.Or"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Or</span></code></a></p></td>
<td><p>Disjunction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.Neg" title="pysat.formula.Neg"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Neg</span></code></a></p></td>
<td><p>Negation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.Implies" title="pysat.formula.Implies"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Implies</span></code></a></p></td>
<td><p>Implication.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.Equals" title="pysat.formula.Equals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Equals</span></code></a></p></td>
<td><p>Equivalence.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.XOr" title="pysat.formula.XOr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">XOr</span></code></a></p></td>
<td><p>Exclusive disjunction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.ITE" title="pysat.formula.ITE"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ITE</span></code></a></p></td>
<td><p>If-then-else operator.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNF</span></code></a></p></td>
<td><p>Class for manipulating CNF formulas.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNFPlus</span></code></a></p></td>
<td><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNF</span></code></a></p></td>
<td><p>Class for manipulating partial (weighted) CNF formulas.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a></p></td>
<td><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Link to this heading">#</a></h2>
<p>This module is designed to facilitate fast and easy PySAT-development by
providing a simple way to manipulate formulas in PySAT. The toolkit
implements several facilities to manupulate Boolean formulas. Namely, one
can opt for creating arbitrary non-clausal formulas suitable for simple
problem encodings requiring no or little knowledge about the process of
logical encoding. However, the main and most often used kind of formula in
PySAT is represented by the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class, which can be used to
define a formula in <a class="reference external" href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form (CNF)</a>.</p>
<p>Recall that a CNF formula is conventionally seen as a set of clauses, each
being a set of literals. A literal is a Boolean variable or its negation.
In PySAT, a Boolean variable and a literal should be specified as an
integer. For instance, a Boolean variable <span class="math notranslate nohighlight">\(x_{25}\)</span> is represented as
integer <code class="docutils literal notranslate"><span class="pre">25</span></code>. A literal <span class="math notranslate nohighlight">\(\neg{x_{10}}\)</span> should be specified as
<code class="docutils literal notranslate"><span class="pre">-10</span></code>. Moreover, a clause <span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span>
should be specified as <code class="docutils literal notranslate"><span class="pre">[-2,</span> <span class="pre">19,</span> <span class="pre">46]</span></code> in PySAT. <em>Unit size clauses</em> are
to be specified as unit size lists as well, e.g. a clause <span class="math notranslate nohighlight">\((x_3)\)</span> is
a list <code class="docutils literal notranslate"><span class="pre">[3]</span></code>.</p>
<p>CNF formulas can be created as an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>. For
instance, the following piece of code creates a CNF formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The clauses of a formula can be accessed through the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable
of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>, which is a list of lists of integers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2 ,3]]</span>
</pre></div>
</div>
<p>The number of variables in a CNF formula, i.e. the <em>largest variable
identifier</em>, can be obtained using the <code class="docutils literal notranslate"><span class="pre">nv</span></code> variable, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> has a few methods to read and write a CNF formula into a
file or a string. The formula is read/written in the standard <a class="reference external" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#SAT_problem_format">DIMACS CNF</a>
format. A clause in the DIMACS format is a string containing
space-separated integer literals  followed by <code class="docutils literal notranslate"><span class="pre">0</span></code>. For instance, a clause
<span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span> is written as <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">19</span> <span class="pre">46</span> <span class="pre">0</span></code>
in DIMACS. The clauses in DIMACS should be preceded by a <em>preamble</em>, which
is a line <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span> <span class="pre">nof_variables</span> <span class="pre">nof_clauses</span></code>, where <code class="docutils literal notranslate"><span class="pre">nof_variables</span></code> and
<code class="docutils literal notranslate"><span class="pre">nof_clauses</span></code> are integers. A preamble line for formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span> would be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span>
<span class="pre">3</span> <span class="pre">2</span></code>. The complete DIMACS file describing the formula looks this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Reading and writing formulas in DIMACS can be done with PySAT in the
following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># reading from file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;another-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># reading from a file pointer</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">f2</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to a file pointer</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Besides plain CNF formulas, the <a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module implements an
additional class for dealing with <em>partial</em> and <em>weighted partial</em> CNF
formulas, i.e. WCNF formulas. A WCNF formula is a conjunction of two sets
of clauses: <em>hard</em> clauses and <em>soft</em> clauses, i.e.
<span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>. Soft clauses of a WCNF
are labeled with integer <em>weights</em>, i.e. a soft clause of
<span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a pair <span class="math notranslate nohighlight">\((c_i, w_i)\)</span>. In partial (unweighted)
formulas, all soft clauses have weight 1.</p>
<p>WCNF can be of help when solving optimization problems using the SAT
technology. A typical example of where a WCNF formula can be used is
<a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_satisfiability_problem">maximum satisfiability (MaxSAT)</a>, which
given a WCNF formula <span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>
targets satisfying all its hard clauses <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> and maximizing
the sum of weights of satisfied soft clauses, i.e. maximizing the value of
<span class="math notranslate nohighlight">\(\sum_{c_i\in\mathcal{S}}{w_i\cdot c_i}\)</span>.</p>
<p>An object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> has two variables to access the hard and
soft clauses of the corresponding formula: <code class="docutils literal notranslate"><span class="pre">hard</span></code> and <code class="docutils literal notranslate"><span class="pre">soft</span></code>. The
weights of soft clauses are stored in variable <code class="docutils literal notranslate"><span class="pre">wght</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># the formula becomes unsatisfiable</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1], [2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>A properly constructed WCNF formula must have a <em>top weight</em>, which should
be equal to <span class="math notranslate nohighlight">\(1+\sum_{c_i\in\mathcal{S}}{w_i}\)</span>. Top weight of a
formula can be accessed through variable <code class="docutils literal notranslate"><span class="pre">topw</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># (1 + 3) + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although it is not aligned with the WCNF format description, starting
with the 0.1.5.dev8 release, PySAT is able to deal with WCNF formulas
having not only integer clause weights but also weights represented as
<em>floating point numbers</em>. Moreover, <em>negative weights</em> are also
supported.</p>
</div>
<p>Additionally to classes <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>, the module
provides the extended classes <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>. The
only difference between <code class="docutils literal notranslate"><span class="pre">?CNF</span></code> and <code class="docutils literal notranslate"><span class="pre">?CNFPlus</span></code> is the support for
<em>native</em> cardinality constraints provided by the <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a> (see <a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a> for
details). The corresponding variable in objects of <code class="docutils literal notranslate"><span class="pre">CNFPlus</span></code>
(<code class="docutils literal notranslate"><span class="pre">WCNFPlus</span></code>, resp.) responsible for storing the AtMostK constraints is
<code class="docutils literal notranslate"><span class="pre">atmosts</span></code> (<code class="docutils literal notranslate"><span class="pre">atms</span></code>, resp.). <strong>Note</strong> that at this point, AtMostK
constraints in <code class="docutils literal notranslate"><span class="pre">WCNF</span></code> can be <em>hard</em> only.</p>
<p>Apart from the aforementioned variants of (W)CNF formulas, the module now
offers a few additional classes for managing non-clausal Boolean formulas.
Namely, a user may create complex formulas using variables (atomic
formulas implemented as objects of class <a class="reference internal" href="#pysat.formula.Atom" title="pysat.formula.Atom"><code class="xref py py-class docutils literal notranslate"><span class="pre">Atom</span></code></a>), and the following
logic connectives: <a class="reference internal" href="#pysat.formula.And" title="pysat.formula.And"><code class="xref py py-class docutils literal notranslate"><span class="pre">And</span></code></a>, <a class="reference internal" href="#pysat.formula.Or" title="pysat.formula.Or"><code class="xref py py-class docutils literal notranslate"><span class="pre">Or</span></code></a>, <a class="reference internal" href="#pysat.formula.Neg" title="pysat.formula.Neg"><code class="xref py py-class docutils literal notranslate"><span class="pre">Neg</span></code></a>,
<a class="reference internal" href="#pysat.formula.Implies" title="pysat.formula.Implies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Implies</span></code></a>, <a class="reference internal" href="#pysat.formula.Equals" title="pysat.formula.Equals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equals</span></code></a>, <a class="reference internal" href="#pysat.formula.XOr" title="pysat.formula.XOr"><code class="xref py py-class docutils literal notranslate"><span class="pre">XOr</span></code></a>, and <a class="reference internal" href="#pysat.formula.ITE" title="pysat.formula.ITE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITE</span></code></a>. (All of
these classes inherit from the base class <a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>.) Arbitrary
combinations of these logic connectives are allowed. Importantly, the
module provides seamless integration of <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and various
subclasses of <a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a> with the possibility to clausify these on
demand.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>

<span class="go"># creating two formulas: CNF and XOr</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xor</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">^</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">^</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

<span class="go"># passing the conjunction of these to the solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">xor</span> <span class="o">&amp;</span> <span class="n">cnf</span><span class="p">)</span> <span class="k">as</span> <span class="n">solver</span><span class="p">:</span>
<span class="gp">... </span>   <span class="c1"># setting Atom(3) to false results in only one model</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">solver</span><span class="o">.</span><span class="n">enum_models</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="n">Formula</span><span class="o">.</span><span class="n">literals</span><span class="p">([</span><span class="o">~</span><span class="n">Atom</span><span class="p">(</span><span class="mi">3</span><span class="p">)])):</span>
<span class="gp">... </span>       <span class="nb">print</span><span class="p">(</span><span class="n">Formula</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">atoms_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>  <span class="c1"># translating the model back to atoms</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="go">[Neg(Atom(1)), Neg(Atom(2)), Neg(Atom(3)), Atom(4)]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Combining CNF formulas with non-CNF ones will not necessarily result
in the best possible encoding of the complex formula. The on-the-fly
encoder may introduce variables that a human would avoid using, e.g.
if <code class="docutils literal notranslate"><span class="pre">cnf1</span></code> and <code class="docutils literal notranslate"><span class="pre">cnf2</span></code> are <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> formulas then <code class="docutils literal notranslate"><span class="pre">And(cnf1,</span>
<span class="pre">cnf2)</span></code> will introduce auxiliary variables <code class="docutils literal notranslate"><span class="pre">v1</span></code> and <code class="docutils literal notranslate"><span class="pre">v2</span></code> encoding
them, respectively (although it is enough to join their sets of
clauses).</p>
</div>
<p>Besides the implementations of CNF and WCNF formulas in PySAT, the
<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module also provides a way to manage variable
identifiers. This can be done with the use of the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> manager.
With the use of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> classes as well as with
the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> variable manager, it is pretty easy to develop
practical problem encoders into SAT or MaxSAT/MinSAT. As an example, a PHP
formula encoder is shown below (the implementation can also be found in
<a class="reference internal" href="examples/genhard.html#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-class docutils literal notranslate"><span class="pre">examples.genhard.PHP</span></code></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>  <span class="c1"># we will store the formula here</span>

<span class="c1"># nof_holes is given</span>

<span class="c1"># initializing the pool of variable ids</span>
<span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">start_from</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pigeon</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;pigeon</span><span class="si">{0}</span><span class="s1">@</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

<span class="c1"># placing all pigeons into holes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># there cannot be more than 1 pigeon in a hole</span>
<span class="n">pigeons</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pigeons</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Link to this heading">#</a></h2>
</section>
<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.And">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">And</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.And" title="Link to this definition">#</a></dt>
<dd><p>Conjunction. Given a list of operands (subformulas) <span class="math notranslate nohighlight">\(f_i\)</span>,
<span class="math notranslate nohighlight">\(i \in \{1,\ldots,n\}, n \in \mathbb{N}\)</span>, it creates a
formula <span class="math notranslate nohighlight">\(\bigwedge_{i=1}^{n}{f_i}\)</span>. The list of operands <em>of
size at least 1</em> should be passed as arguments to the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>If an additional Boolean keyword argument <code class="docutils literal notranslate"><span class="pre">merge</span></code> is provided set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the toolkit will try to flatten the current <a class="reference internal" href="#pysat.formula.And" title="pysat.formula.And"><code class="xref py py-class docutils literal notranslate"><span class="pre">And</span></code></a>
formula merging its <em>conjuctive</em> sub-operands into the list of
operands. For example, if <code class="docutils literal notranslate"><span class="pre">And(And(x,</span> <span class="pre">y),</span> <span class="pre">z,</span> <span class="pre">merge=True)</span></code> is called,
a new Formula object will be created with two operands: <code class="docutils literal notranslate"><span class="pre">And(x,</span> <span class="pre">y)</span></code>
and <code class="docutils literal notranslate"><span class="pre">z</span></code>, followed by merging <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> into the list of
root-level <code class="docutils literal notranslate"><span class="pre">And</span></code>. This will result in a formula <code class="docutils literal notranslate"><span class="pre">And(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.
Merging sub-operands is enabled by default if bitwise operations are
used to create <code class="docutils literal notranslate"><span class="pre">And</span></code> formulas.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">And</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="go">&quot;And[And[Atom(&#39;x&#39;), Atom(&#39;y&#39;)], Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">&quot;And[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">&quot;And[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">True  # formulas a2 and a3 refer to the same object</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are two formulas representing the same fact with and
without merging enabled, they technically sit in two distinct
objects. Although PySAT tries to avoid it, clausification of these
two formulas may result in unique (different) auxiliary variables
assigned to such two formulas.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.And.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.And.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformulas and creates a new formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">&amp;</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">x &amp; z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">F  # False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Atom">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Atom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Atom" title="Link to this definition">#</a></dt>
<dd><p>Atomic formula, i.e. a variable or constant. Although we often refer
to negated literals as atomic formulas too, they are techically
implemented as <code class="docutils literal notranslate"><span class="pre">Neg(Atom)</span></code>.</p>
<p>To create an atomic formula, a user needs to specify an <code class="docutils literal notranslate"><span class="pre">object</span></code>
this formula should signify. When it comes to clausifying the formulas
this atom is involved in, the atom receives an auxiliary variable
assigned to it as a <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="nb">object</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># checking x&#39;s name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">name</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># right, that&#39;s because the atom is not yet clausified</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">clausify</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">name</span>
<span class="go">1</span>
</pre></div>
</div>
<p>If a given object is a positive integer (negative integers arent
allowed), the integer itself serves as the atoms name, which is
assigned in the constructor, i.e. no call to <code class="xref py py-meth docutils literal notranslate"><span class="pre">clausify()</span></code> is
required.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">Atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="o">.</span><span class="n">name</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">y</span><span class="o">.</span><span class="n">name</span>
<span class="go">2</span>
</pre></div>
</div>
<p>Special atoms are reserved for the Boolean constants <code class="docutils literal notranslate"><span class="pre">True</span></code> and
<code class="docutils literal notranslate"><span class="pre">False</span></code>. Namely, <code class="docutils literal notranslate"><span class="pre">Atom(False)</span></code> and <code class="docutils literal notranslate"><span class="pre">Atom(True)</span></code> can be accessed
through the constants <code class="docutils literal notranslate"><span class="pre">PYSAT_FALSE</span></code> and <code class="docutils literal notranslate"><span class="pre">PYSAT_TRUE</span></code>,
respectively.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">PYSAT_TRUE</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">PYSAT_TRUE</span><span class="p">))</span>
<span class="go">T Atom(True)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">PYSAT_FALSE</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">PYSAT_FALSE</span><span class="p">))</span>
<span class="go">F Atom(False)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Constant <code class="docutils literal notranslate"><span class="pre">Atom(True)</span></code> is distinguished from variable <code class="docutils literal notranslate"><span class="pre">Atom(1)</span></code>
by checking the type of the object (bool vs int).</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Atom.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Atom.simplified" title="Link to this definition">#</a></dt>
<dd><p>Checks if the current literal appears in the list of assumptions
provided in argument <code class="docutils literal notranslate"><span class="pre">assumptions</span></code>. If it is, the method returns
<code class="docutils literal notranslate"><span class="pre">PYSAT_TRUE</span></code>. If the opposite atom is present in
<code class="docutils literal notranslate"><span class="pre">assumptions</span></code>, the method returns <code class="docutils literal notranslate"><span class="pre">PYSAT_FALSE</span></code>. Otherwise, it
return <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>PYSAT_TRUE, PYSAT_FALSE, or self</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.CNF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">CNF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF" title="Link to this definition">#</a></dt>
<dd><p>Class for manipulating CNF formulas. It can be used for creating
formulas, reading them from a file, or writing them to a file. The
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to parse
specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_file</strong> (<em>str</em>)  a DIMACS CNF filename to read from</p></li>
<li><p><strong>from_fp</strong> (<em>file_pointer</em>)  a file pointer to read from</p></li>
<li><p><strong>from_string</strong> (<em>str</em>)  a string storing a CNF formula</p></li>
<li><p><strong>from_clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  a list of clauses to bootstrap the formula with</p></li>
<li><p><strong>from_aiger</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> (see <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>))  an AIGER circuit to bootstrap the formula with</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
<li><p><strong>by_ref</strong> (<em>bool</em>)  flag to indicate how to copy clauses - by reference or deep-copy</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">update_vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.append" title="Link to this definition">#</a></dt>
<dd><p>Add one more clause to CNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used
in the formula.</p>
<p>The additional keyword argument <code class="docutils literal notranslate"><span class="pre">update_vpool</span></code> can be set to
<code class="docutils literal notranslate"><span class="pre">True</span></code> if the user wants to update for default static pool of
variable identifiers stored in class <a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>. In light of
the fact that a user may encode their problem manually and add
thousands to millions of clauses using this method, the value of
<code class="docutils literal notranslate"><span class="pre">update_vpool</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Setting <code class="docutils literal notranslate"><span class="pre">update_vpool=True</span></code> is required if a user wants to
combine this <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> formula with other (clausal or
non-clausal) formulas followed by the clausification of the
result combination. Alternatively, a user may resort to using
the method <a class="reference internal" href="#pysat.formula.CNF.extend" title="pysat.formula.CNF.extend"><code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code></a> instead.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>)  a new clause to add</p></li>
<li><p><strong>update_vpool</strong> (<em>bool</em>)  update or not the static vpool</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [3], [-3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.copy" title="Link to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a CNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy the clauses.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.extend" title="Link to this definition">#</a></dt>
<dd><p>Add several clauses to CNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.CNF.append" title="pysat.formula.CNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  a list of new clauses to add</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [3], [-3, 4], [5, 6]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_aiger">
<span class="sig-name descname"><span class="pre">from_aiger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_aiger" title="Link to this definition">#</a></dt>
<dd><p>Create a CNF formula by Tseitin-encoding an input AIGER circuit.</p>
<p>Input circuit is expected to be an object of class
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code>. Alternatively, it can be specified as an
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.BoolExpr</span></code>, or an <code class="docutils literal notranslate"><span class="pre">*.aag</span></code> filename, or an AIGER
string to parse. (Classes <code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.BoolExpr</span></code> are defined in the <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aig</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> (see <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>))  an input AIGER circuit</p></li>
<li><p><strong>vpool</strong> (<a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>)  pool of variable identifiers (optional)</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">aiger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">aig</span><span class="p">)</span>
<span class="go">aag 5 3 0 1 2</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">6 3 5</span>
<span class="go">10 6 8</span>
<span class="go">i0 y</span>
<span class="go">i1 x</span>
<span class="go">i2 z</span>
<span class="go">o0 6c454aea-c9e1-11e9-bbe3-3af9d34370a9</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_aiger</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">aig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[3, 2, 4], [-3, -4], [-2, -4], [-4, -1, 5], [4, -5], [1, -5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> &lt;-&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cnf</span><span class="o">.</span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnf</span><span class="o">.</span><span class="n">inps</span><span class="p">])</span>
<span class="go">[&#39;3 &lt;-&gt; y&#39;, &#39;2 &lt;-&gt; x&#39;, &#39;1 &lt;-&gt; z&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> &lt;-&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cnf</span><span class="o">.</span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnf</span><span class="o">.</span><span class="n">outs</span><span class="p">])</span>
<span class="go">[&#39;5 &lt;-&gt; 6c454aea-c9e1-11e9-bbe3-3af9d34370a9&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_clauses">
<span class="sig-name descname"><span class="pre">from_clauses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">by_ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_clauses" title="Link to this definition">#</a></dt>
<dd><p>This methods copies a list of clauses into a CNF object. The
optional keyword argument <code class="docutils literal notranslate"><span class="pre">by_ref</span></code>, which is by default set to
<code class="docutils literal notranslate"><span class="pre">False</span></code>, signifies whether the clauses should be deep-copied or
copied by reference (by default, deep-copying is applied although
it is slower).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  a list of clauses</p></li>
<li><p><strong>by_ref</strong> (<em>bool</em>)  a flag to indicate whether to deep-copy the clauses or copy them by reference</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1, -2], [5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressed_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_file" title="Link to this definition">#</a></dt>
<dd><p>Read a CNF formula from a file in the DIMACS format. A file name is
expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> for
parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>)  name of a file to parse.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
<li><p><strong>compressed_with</strong> (<em>str</em>)  file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.cnf.gz&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_fp" title="Link to this definition">#</a></dt>
<dd><p>Read a CNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_string">
<span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_string" title="Link to this definition">#</a></dt>
<dd><p>Read a CNF formula from a string. The string should be specified as
an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string</strong> (<em>str</em>)  a string containing the formula in DIMACS.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s1">&#39;p cnf 2 2</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1, -2]]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.negate">
<span class="sig-name descname"><span class="pre">negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.negate" title="Link to this definition">#</a></dt>
<dd><p>Given a CNF formula <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, this method creates a
CNF formula <span class="math notranslate nohighlight">\(\neg{\mathcal{F}}\)</span>. The negation of the
formula is encoded to CNF with the use of <em>auxiliary</em> Tseitin
variables <a class="footnote-reference brackets" href="#id2" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>. A new CNF formula is returned keeping all the
newly introduced variables that can be accessed through the
<code class="docutils literal notranslate"><span class="pre">auxvars</span></code> variable. All the literals used to encode the negation
of the original clauses can be accessed through the <code class="docutils literal notranslate"><span class="pre">enclits</span></code>
variable.</p>
<p><strong>Note</strong> that the negation of each clause is encoded with one
auxiliary variable if it is not unit size. Otherwise, no auxiliary
variable is introduced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>topv</strong> (<em>int</em>)  top variable identifier if any.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id2" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>G. S. Tseitin. <em>On the complexity of derivations in the
propositional calculus</em>.  Studies in Mathematics and
Mathematical Logic, Part II. pp.  115125, 1968</p>
</aside>
</aside>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neg</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[1, -4], [-2, -4], [-1, 2, 4], [4, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">auxvars</span><span class="p">)</span>
<span class="go">[4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">enclits</span><span class="p">)</span>  <span class="c1"># literals encoding the negation of clauses</span>
<span class="go">[4, -3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.simplified" title="Link to this definition">#</a></dt>
<dd><p>As any other Formula type, CNF formulas have this method, although
intentionally left unimplemented. Raises a <code class="docutils literal notranslate"><span class="pre">FormulaError</span></code>
exception.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_alien" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to dump a CNF formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format lp, opb, or smt may be
specified (equal to opb by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>)  alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_dimacs" title="Link to this definition">#</a></dt>
<dd><p>Return the current state of the object in DIMACS format.</p>
<p>For example, if some-file.cnf contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p cnf 3 3</span>
<span class="go">-1 2 0</span>
<span class="go">-2 3 0</span>
<span class="go">-3 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_dnf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_file" title="Link to this definition">#</a></dt>
<dd><p>The method is for saving a CNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>)  a file name where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
<li><p><strong>as_dnf</strong> (<em>bool</em>)  a flag to use for specifying dnf in the preamble.</p></li>
<li><p><strong>compress_with</strong> (<em>str</em>)  file compression algorithm.</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">as_dnf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_fp" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to save a CNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
<li><p><strong>as_dnf</strong> (<em>bool</em>)  a flag to use for specifying dnf in the preamble.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.weighted">
<span class="sig-name descname"><span class="pre">weighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.weighted" title="Link to this definition">#</a></dt>
<dd><p>This method creates a weighted copy of the internal formula. As a
result, an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> is returned. Every clause
of the CNF formula is <em>soft</em> in the new WCNF formula and its weight
is equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The set of hard clauses of the formula is empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">cnf</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, 2], [3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">CNFPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus" title="Link to this definition">#</a></dt>
<dd><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> assumes the
syntax of AtMostK and AtLeastK constraints defined in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Additionally, <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> support pseudo-Boolean constraints,
i.e. weighted linear constraints by extending the above format.
Basically, a pseudo-Boolean constraint needs to specify all the
summands as <code class="docutils literal notranslate"><span class="pre">weight*literal</span></code> with the entire constraint being
prepended with character <code class="docutils literal notranslate"><span class="pre">w</span></code> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">One</span> <span class="n">cardinality</span> <span class="n">constraint</span> <span class="ow">and</span> <span class="n">one</span> <span class="n">PB</span> <span class="n">constraint</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="n">w</span> <span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="mi">2</span><span class="o">*</span><span class="mi">5</span> <span class="mi">1</span><span class="o">*</span><span class="mi">6</span> <span class="mi">3</span><span class="o">*-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK
constraints are stored in variable <code class="docutils literal notranslate"><span class="pre">atmosts</span></code>, each being a pair
<code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and
<code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf+ 7 3</span><span class="se">\n</span><span class="s1">1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1"> 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_atmost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.append" title="Link to this definition">#</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to CNF+ formula.
This method additionally updates the number of variables, i.e.
variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>)  a new clause to add.</p></li>
<li><p><strong>is_atmost</strong> (<em>bool</em>)  if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[1, 2, 3], 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.copy" title="Link to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a CNFPlus object.
It creates another object of the <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> class, call the
copy function of CNF class and makes use of the <em>deepcopy</em>
functionality to copy the atmost constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.extend" title="Link to this definition">#</a></dt>
<dd><p>Extend the CNF+ formula with more clauses and/or AtMostK
constraints. The additional clauses and AtMostK constraints to add
should be given in the form of <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>. Alternatively, a
list of clauses can be added too. For every single clause and
AtMostK constraint in the input formula, method <a class="reference internal" href="#pysat.formula.CNFPlus.append" title="pysat.formula.CNFPlus.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is
invoked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>formula</strong> (<a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>)  new constraints to add.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cnf1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.from_fp" title="Link to this definition">#</a></dt>
<dd><p>Read a CNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_alien" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to dump a CNF+ formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format lp, opb, or smt may be
specified (equal to opb by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB2</a> does
not directly support PB constraints. As a result, native
cardinality constraints of CNF+ cannot be translated to
SMT-LIB2 unless an explicit cardinality encoding is applied.
You may want to use Z3s API instead (see its PB interface).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>)  alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_dimacs" title="Link to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if some-file.cnf contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p cnf+ 7 3</span>
<span class="go">3 5 7 0</span>
<span class="go">1 -2 3 5 -7 &lt;= 3</span>
<span class="go">-4 -5 -6 7 &lt;= 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_fp" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to save a CNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.weighted">
<span class="sig-name descname"><span class="pre">weighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.weighted" title="Link to this definition">#</a></dt>
<dd><p>This method creates a weighted copy of the internal formula. As a
result, an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> is returned. Every
clause of the CNFPlus formula is <em>soft</em> in the new WCNFPlus
formula and its weight is equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The set of hard clauses
of the new formula is empty. The set of cardinality constraints
remains unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">cnf</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, 2], [3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Equals">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Equals" title="Link to this definition">#</a></dt>
<dd><p>Equivalence. Given a list of operands (subformulas) <span class="math notranslate nohighlight">\(f_i\)</span>,
<span class="math notranslate nohighlight">\(i \in \{1,\ldots,n\}, n \in \mathbb{N}\)</span>, it creates a
formula <span class="math notranslate nohighlight">\(f_1 \leftrightarrow f_2
\leftrightarrow\ldots\leftrightarrow f_n\)</span>. The list of operands <em>of
size at least 2</em> should be passed as arguments to the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">equiv</span> <span class="o">=</span> <span class="n">Equals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>If an additional Boolean keyword argument <code class="docutils literal notranslate"><span class="pre">merge</span></code> is provided set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the toolkit will try to flatten the current <a class="reference internal" href="#pysat.formula.Equals" title="pysat.formula.Equals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equals</span></code></a>
formula merging its <em>equivalence</em> sub-operands into the list of
operands. For example, if <code class="docutils literal notranslate"><span class="pre">Equals(Equals(x,</span> <span class="pre">y),</span> <span class="pre">z,</span> <span class="pre">merge=True)</span></code> is
called, a new Formula object will be created with two operands:
<code class="docutils literal notranslate"><span class="pre">Equals(x,</span> <span class="pre">y)</span></code> and <code class="docutils literal notranslate"><span class="pre">z</span></code>, followed by merging <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> into
the list of root-level <code class="docutils literal notranslate"><span class="pre">Equals</span></code>. This will result in a formula
<code class="docutils literal notranslate"><span class="pre">Equals(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Merging sub-operands is enabled by default if
bitwise operations are used to create <code class="docutils literal notranslate"><span class="pre">Equals</span></code> formulas.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Equals</span><span class="p">(</span><span class="n">Equals</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Equals</span><span class="p">(</span><span class="n">Equals</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="go">(x @ y) @ z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">x @ y @ z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">x @ y @ z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">True  # formulas a2 and a3 refer to the same object</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are two formulas representing the same fact with and
without merging enabled, they technically sit in two distinct
objects. Although PySAT tries to avoid it, clausification of these
two formulas may result in unique (different) auxiliary variables
assigned to such two formulas.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Equals.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Equals.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformulas and creates a new formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">@</span> <span class="n">y</span> <span class="o">@</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">x &amp; z    # x and z must also be True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~x &amp; ~z  # x and z must also be False</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Formula">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Formula</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula" title="Link to this definition">#</a></dt>
<dd><p>Abstract formula class. At the same time, the class is a factory for
its children and can be used this way although it is recommended to
create objects of the children classes directly. In particular, its
children classes include <a class="reference internal" href="#pysat.formula.Atom" title="pysat.formula.Atom"><code class="xref py py-class docutils literal notranslate"><span class="pre">Atom</span></code></a> (atomic formulas - variables
and constants), <a class="reference internal" href="#pysat.formula.Neg" title="pysat.formula.Neg"><code class="xref py py-class docutils literal notranslate"><span class="pre">Neg</span></code></a> (negations), <a class="reference internal" href="#pysat.formula.And" title="pysat.formula.And"><code class="xref py py-class docutils literal notranslate"><span class="pre">And</span></code></a> (conjunctions),
<a class="reference internal" href="#pysat.formula.Or" title="pysat.formula.Or"><code class="xref py py-class docutils literal notranslate"><span class="pre">Or</span></code></a> (disjunctions), <a class="reference internal" href="#pysat.formula.Implies" title="pysat.formula.Implies"><code class="xref py py-class docutils literal notranslate"><span class="pre">Implies</span></code></a> (implications),
<a class="reference internal" href="#pysat.formula.Equals" title="pysat.formula.Equals"><code class="xref py py-class docutils literal notranslate"><span class="pre">Equals</span></code></a> (equalities), <a class="reference internal" href="#pysat.formula.XOr" title="pysat.formula.XOr"><code class="xref py py-class docutils literal notranslate"><span class="pre">XOr</span></code></a> (exclusive disjunctions),
and <a class="reference internal" href="#pysat.formula.ITE" title="pysat.formula.ITE"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITE</span></code></a> (if-then-else operations).</p>
<p>Due to the need to clausify formulas, an object of any subclass of
<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a> is meant to be represented in memory by a single
copy. This is achieved by storing a dictionary of all the known
formulas attached to a given <em>context</em>. Thus, once a particular
context is activated, its dictionary will make sure each formula
variable refers to a single representation of the formula object it
aims to refer. When it comes to clausifying this formula, the formula
is encoded exactly once, despite it may be potentially used multiple
times as part of one of more complex formulas.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
<span class="go">True  # x1 and x2 refer to the same atom</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">x1</span> <span class="o">&amp;</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">))</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">x2</span><span class="p">)</span>
<span class="go">True  # it holds if constructing complex formulas with them as subformulas</span>
</pre></div>
</div>
<p>The class supports multi-context operation. A user may have formulas
created and clausified in different context. They can also switch from
one context to another and/or cleanup the instances known in some or
all contexts.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">And</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>  <span class="c1"># arbitrary formula</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># by default, the context is set to &#39;default&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># another context can be created like this:</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Formula</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="s1">&#39;some-other-context&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the new context knows nothing about formula f1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># ...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># cleaning up context &#39;some-other-context&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># this deletes all the formulas known in this context</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Formula</span><span class="o">.</span><span class="n">cleanup</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="s1">&#39;some-other-context&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># switching back to &#39;default&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Formula</span><span class="o">.</span><span class="n">set_context</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A user may also want to disable duplicate blocking, which can be
achieved by setting the context to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
<p>Boolean constants False and True are represented by the atomic
formulas <code class="docutils literal notranslate"><span class="pre">Atom(False)</span></code> and <code class="docutils literal notranslate"><span class="pre">Atom(True)</span></code>, respectively. There are
two constants storing these values: <code class="docutils literal notranslate"><span class="pre">PYSAT_FALSE</span></code> and
<code class="docutils literal notranslate"><span class="pre">PYSAT_TRUE</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">PYSAT_FALSE</span><span class="p">,</span> <span class="n">PYSAT_TRUE</span>
<span class="go">(Atom(False), Atom(True))</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.atoms">
<span class="sig-name descname"><span class="pre">atoms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">constants</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.atoms" title="Link to this definition">#</a></dt>
<dd><p>Returns a list of all the atomic formulas (variables and, if
required, constants) that this formula is built from. The method
recursively traverses the formula tree and collects all the atoms
it finds.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>constants</strong> (<em>bool</em>)  include Boolean constants in the list</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(<a class="reference internal" href="#pysat.formula.Atom" title="pysat.formula.Atom"><code class="xref py py-class docutils literal notranslate"><span class="pre">Atom</span></code></a>)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">atoms</span><span class="p">()</span>
<span class="go">[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.attach_vpool">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">attach_vpool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vpool</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.attach_vpool" title="Link to this definition">#</a></dt>
<dd><p>Attach an external <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> to be associated with a given
context. This is useful when a user has an already created
<a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> object and wants to reuse it when clausifying
their <a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a> objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vpool</strong> (<a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>)  an external variable manager</p></li>
<li><p><strong>context</strong> (<em>hashable</em>)  target context to be the user of the vpool</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.clausify">
<span class="sig-name descname"><span class="pre">clausify</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.clausify" title="Link to this definition">#</a></dt>
<dd><p>This method applies Tseitin transformation to the formula.
Recursively gives all the formulas Boolean names accordingly and
uses them in the current logic connective following its semantics.
As a result, each subformula stores its clausal representation
independently of other subformulas (and independently of the root
formula).</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">clausify</span><span class="p">()</span>  <span class="c1"># clausifying formula a</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># let&#39;s what clauses represent the root logic connective</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">clauses</span>
<span class="go">[[3, 4]]  # 4 corresponds to z while 3 represents the equality x @ y</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.cleanup">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cleanup</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.cleanup" title="Link to this definition">#</a></dt>
<dd><p>Clean up either a given context (if specified as different from
<code class="docutils literal notranslate"><span class="pre">None</span></code>) or all contexts (otherwise); afterwards, start the
default context from scratch.</p>
<p>A context is cleaned by destroying all the associated
<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a> objects and all the corresponding variable
managers. This may be useful if a user wants to start encoding
their problem from scratch.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once cleaning of a context is done, the objects referring to
the contexts formulas must not be used. At this point, they
are orphaned and cant get re-clausified.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<code class="docutils literal notranslate"><span class="pre">None</span></code> or hashable)  target context</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.export_vpool">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">export_vpool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">active</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.export_vpool" title="Link to this definition">#</a></dt>
<dd><p>Opposite to <a class="reference internal" href="#pysat.formula.Formula.attach_vpool" title="pysat.formula.Formula.attach_vpool"><code class="xref py py-meth docutils literal notranslate"><span class="pre">attach_vpool()</span></code></a>, this method returns a variable
managed attached to a given context, which may be useful for
external use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>active</strong> (<em>bool</em>)  export the currently active context</p></li>
<li><p><strong>context</strong> (<em>hashable</em>)  context using the vpool we are interested in (if <code class="docutils literal notranslate"><span class="pre">active</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.formulas">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">formulas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.formulas" title="Link to this definition">#</a></dt>
<dd><p>Given a list of integer literal identifiers, this method returns a
list of formulas corresponding to these identifiers. Basically,
the method can be seen as mapping auxiliary variables naming
formulas to the corresponding formulas they name.</p>
<p>If the argument <code class="docutils literal notranslate"><span class="pre">atoms_only</span></code> is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> only, the method
will return a subset of formulas, including only atomic formulas
(literals). Otherwise, any formula whose name occurs in the input
list will be included in the result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em>)  input list of literals</p></li>
<li><p><strong>atoms_only</strong> (<em>bool</em>)  include all known formulas or atomic ones only</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">^</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">Solver</span><span class="p">(</span><span class="n">bootstrap_with</span><span class="o">=</span><span class="n">a</span><span class="p">)</span> <span class="k">as</span> <span class="n">solver</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">solver</span><span class="o">.</span><span class="n">enum_models</span><span class="p">():</span>
<span class="gp">... </span>        <span class="c1"># using method formulas to map the model back to atoms</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">Formula</span><span class="o">.</span><span class="n">formulas</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">atoms_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
<span class="gp">...</span>
<span class="go">[Neg(Atom(&#39;x&#39;)), Neg(Atom(&#39;y&#39;)), Neg(Atom(&#39;z&#39;))]</span>
<span class="go">[Neg(Atom(&#39;x&#39;)), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]</span>
<span class="go">[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Neg(Atom(&#39;z&#39;))]</span>
<span class="go">[Atom(&#39;x&#39;), Neg(Atom(&#39;y&#39;)), Atom(&#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.literals">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">literals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">forms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.literals" title="Link to this definition">#</a></dt>
<dd><p>Extract formula names for a given list of formulas and return them
as a list of integer identifiers. Essentially, the method is the
opposite to <a class="reference internal" href="#pysat.formula.Formula.formulas" title="pysat.formula.Formula.formulas"><code class="xref py py-meth docutils literal notranslate"><span class="pre">formulas()</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>forms</strong> (<em>iterable</em>)  list of formulas to map</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list(int)</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.solvers</span> <span class="kn">import</span> <span class="n">Solver</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">^</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># applying Tseitin transformation to formula a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">clausify</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># checking what facts the internal vpool knows</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">Formula</span><span class="o">.</span><span class="n">export_vpool</span><span class="p">()</span><span class="o">.</span><span class="n">id2obj</span><span class="p">)</span>
<span class="go">{1: Atom(&#39;x&#39;), 2: Atom(&#39;y&#39;), 3: Equals[Atom(&#39;x&#39;), Atom(&#39;y&#39;)], 4: Atom(&#39;z&#39;)}</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># now, mapping two atoms to their integer id representations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Formula</span><span class="o">.</span><span class="n">literals</span><span class="p">(</span><span class="n">forms</span><span class="o">=</span><span class="p">[</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="o">~</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)])</span>
<span class="go">[1, -4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.satisfied">
<span class="sig-name descname"><span class="pre">satisfied</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.satisfied" title="Link to this definition">#</a></dt>
<dd><p>Given a list of atomic formulas, this method checks whether the
current formula is satisfied by assigning these atoms. The method
returns <code class="docutils literal notranslate"><span class="pre">True</span></code> if the formula gets satisfied, <code class="docutils literal notranslate"><span class="pre">False</span></code> if it is
falsified, and <code class="docutils literal notranslate"><span class="pre">None</span></code> if the answer is unknown.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>model</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  list of atomic formulas</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool or <code class="docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">satisfied</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">satisfied</span><span class="p">(</span><span class="n">model</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">z</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># None, as it is not enough to set ~z to determine satisfiability of a</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.set_context">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">set_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">context</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'default'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.set_context" title="Link to this definition">#</a></dt>
<dd><p>Set the current context of interest. If set to <code class="docutils literal notranslate"><span class="pre">None</span></code>, no
context will be assumed and duplicate checking will be disabled as
a result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>context</strong> (<em>hashable</em>)  new active context</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Formula.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Formula.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption atomic formula literals, this method
recursively assigns these atoms to the corresponding values
followed by formula simplification. As a result, a new formula
object is returned.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (<em>list</em>)  atomic formula objects</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">@</span> <span class="n">y</span><span class="p">)</span> <span class="o">|</span> <span class="n">z</span>  <span class="c1"># a formula over 3 variables: x, y, and z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">z</span><span class="p">])</span>
<span class="go">Atom(True)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">z</span><span class="p">])</span>
<span class="go">Equals[Atom(&#39;x&#39;), Atom(&#39;y&#39;)]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span> <span class="o">^</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)</span>  <span class="c1"># a more complex formula</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="o">~</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;p&#39;</span><span class="p">)])</span>
<span class="go">Or[Atom(&#39;y&#39;), Atom(&#39;z&#39;)]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pysat.formula.FormulaError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">FormulaError</span></span><a class="headerlink" href="#pysat.formula.FormulaError" title="Link to this definition">#</a></dt>
<dd><p>This exception is raised when an formula-related issue occurs.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.FormulaType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">FormulaType</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">value</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.FormulaType" title="Link to this definition">#</a></dt>
<dd><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the formula
type to use. The values denoting all the formula types are as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ATOM</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">AND</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">OR</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">NEG</span> <span class="o">=</span> <span class="mi">3</span>
<span class="n">IMPL</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">EQ</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">XOR</span> <span class="o">=</span> <span class="mi">6</span>
<span class="n">ITE</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.IDPool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">IDPool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_from</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool" title="Link to this definition">#</a></dt>
<dd><p>A simple manager of variable IDs. It can be used as a pool of integers
assigning an ID to any object. Identifiers are to start from <code class="docutils literal notranslate"><span class="pre">1</span></code> by
default. The list of occupied intervals is empty be default. If
necessary the top variable ID can be accessed directly using the
<code class="docutils literal notranslate"><span class="pre">top</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_from</strong> (<em>int</em>)  the smallest ID to assign.</p></li>
<li><p><strong>occupied</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  a list of occupied intervals.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.id" title="Link to this definition">#</a></dt>
<dd><p>The method is to be used to assign an integer variable ID for a
given new object. If the object already has an ID, no new ID is
created and the old one is returned instead.</p>
<p>An object can be anything. In some cases it is convenient to use
string variable names. Note that if the object is not provided,
the method will return a new id unassigned to any object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>obj</strong>  an object to assign an ID to.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">IDPool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">occupied</span><span class="o">=</span><span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># creating 5 unique variables for the following strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;v</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">11</span>
<span class="go">19</span>
<span class="go">20</span>
</pre></div>
</div>
<p>In some cases, it makes sense to create an external function for
accessing IDPool, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># continuing the previous example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;var</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;hello_world!&#39;</span><span class="p">)</span>
<span class="go">21</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.obj">
<span class="sig-name descname"><span class="pre">obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.obj" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to map back a given variable identifier to
the original object labeled by the identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>vid</strong> (<em>int</em>)  variable identifier.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>an object corresponding to the given identifier.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">&#39;hello_world!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.occupy">
<span class="sig-name descname"><span class="pre">occupy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.occupy" title="Link to this definition">#</a></dt>
<dd><p>Mark a given interval as occupied so that the manager could skip
the values from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">stop</span></code> (<strong>inclusive</strong>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>int</em>)  beginning of the interval.</p></li>
<li><p><strong>stop</strong> (<em>int</em>)  end of the interval.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.restart">
<span class="sig-name descname"><span class="pre">restart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_from</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.restart" title="Link to this definition">#</a></dt>
<dd><p>Restart the manager from scratch. The arguments replicate those of
the constructor of <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.ITE">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">ITE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.ITE" title="Link to this definition">#</a></dt>
<dd><p>If-then-else operator. Given three operands (subformulas) <span class="math notranslate nohighlight">\(x\)</span>,
<span class="math notranslate nohighlight">\(y\)</span>, and <span class="math notranslate nohighlight">\(z\)</span>, it creates a formula <span class="math notranslate nohighlight">\((x \rightarrow
y) \land (\neg{x} \rightarrow z)\)</span>. The operands should be passed as
arguments to the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ite</span> <span class="o">=</span> <span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ite</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.ITE.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.ITE.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformulas and creates a new formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ite</span> <span class="o">=</span> <span class="n">ITE</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ite</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">x | z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ite</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~x &amp; z</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Implies">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Implies</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Implies" title="Link to this definition">#</a></dt>
<dd><p>Implication. Given two operands <span class="math notranslate nohighlight">\(f_1\)</span> and <span class="math notranslate nohighlight">\(f_2\)</span>, it
creates a formula <span class="math notranslate nohighlight">\(f_1 \rightarrow f_2\)</span>. The operands must be
passed to the constructors either as two arguments or two keyword
arguments <code class="docutils literal notranslate"><span class="pre">left</span></code> and <code class="docutils literal notranslate"><span class="pre">right</span></code>.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Implies</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">x &gt;&gt; y</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Implies.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Implies.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
left and right subformulas and then creates and returns a new
formula with these simplified subformulas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&gt;&gt;</span> <span class="n">y</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">T</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~x</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Neg">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Neg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Neg" title="Link to this definition">#</a></dt>
<dd><p>Negation. Given a single operand (subformula) <span class="math notranslate nohighlight">\(f\)</span>, it creates a
formula <span class="math notranslate nohighlight">\(\neg{f}\)</span>. The operand must be passed as an argument to
the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n1</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n2</span> <span class="o">=</span> <span class="n">Neg</span><span class="p">(</span><span class="n">subformula</span><span class="o">=</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
<span class="go">~x, ~x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n3</span> <span class="o">=</span> <span class="o">~</span><span class="n">n1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">n3</span><span class="p">)</span>
<span class="go">x</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Neg.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Neg.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformula and then creates and returns a new formula with this
simplified subformula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">y</span> <span class="o">|</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="o">~</span><span class="n">a</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~(x | z)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~z</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.Or">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">Or</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Or" title="Link to this definition">#</a></dt>
<dd><p>Disjunction. Given a list of operands (subformulas) <span class="math notranslate nohighlight">\(f_i\)</span>,
<span class="math notranslate nohighlight">\(i \in \{1,\ldots,n\}, n \in \mathbb{N}\)</span>, it creates a
formula <span class="math notranslate nohighlight">\(\bigvee_{i=1}^{n}{f_i}\)</span>. The list of operands <em>of size
at least 1</em> should be passed as arguments to the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">conj</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>If an additional Boolean keyword argument <code class="docutils literal notranslate"><span class="pre">merge</span></code> is provided set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the toolkit will try to flatten the current <a class="reference internal" href="#pysat.formula.Or" title="pysat.formula.Or"><code class="xref py py-class docutils literal notranslate"><span class="pre">Or</span></code></a>
formula merging its <em>conjuctive</em> sub-operands into the list of
operands. For example, if <code class="docutils literal notranslate"><span class="pre">Or(Or(x,</span> <span class="pre">y),</span> <span class="pre">z,</span> <span class="pre">merge=True)</span></code> is called, a
new Formula object will be created with two operands: <code class="docutils literal notranslate"><span class="pre">Or(x,</span> <span class="pre">y)</span></code> and
<code class="docutils literal notranslate"><span class="pre">z</span></code>, followed by merging <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> into the list of root-level
<code class="docutils literal notranslate"><span class="pre">Or</span></code>. This will result in a formula <code class="docutils literal notranslate"><span class="pre">Or(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>. Merging
sub-operands is enabled by default if bitwise operations are used to
create <code class="docutils literal notranslate"><span class="pre">Or</span></code> formulas.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">Or</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="go">&quot;Or[Or[Atom(&#39;x&#39;), Atom(&#39;y&#39;)], Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">&quot;Or[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">repr</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">&quot;Or[Atom(&#39;x&#39;), Atom(&#39;y&#39;), Atom(&#39;z&#39;)]&quot;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">True  # formulas a2 and a3 refer to the same object</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are two formulas representing the same fact with and
without merging enabled, they technically sit in two distinct
objects. Although PySAT tries to avoid it, clausification of these
two formulas may result in unique (different) auxiliary variables
assigned to such two formulas.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.Or.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.Or.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformulas and creates a new formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">|</span> <span class="n">y</span> <span class="o">|</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">T  # True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">x | z</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.WCNF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">WCNF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF" title="Link to this definition">#</a></dt>
<dd><p>Class for manipulating partial (weighted) CNF formulas. It can be used
for creating formulas, reading them from a file, or writing them to a
file. The <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to
parse specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_file</strong> (<em>str</em>)  a DIMACS CNF filename to read from</p></li>
<li><p><strong>from_fp</strong> (<em>file_pointer</em>)  a file pointer to read from</p></li>
<li><p><strong>from_string</strong> (<em>str</em>)  a string storing a CNF formula</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.append" title="Link to this definition">#</a></dt>
<dd><p>Add one more clause to WCNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in
the formula.</p>
<p>The clause can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code>
argument. If no weight is set, the clause is considered to be hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>)  a new clause to add.</p></li>
<li><p><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>)  integer weight of the clause.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1], [-2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10, 20]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.copy" title="Link to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a WCNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy both hard and soft clauses.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.extend" title="Link to this definition">#</a></dt>
<dd><p>Add several clauses to WCNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.WCNF.append" title="pysat.formula.WCNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<p>The clauses can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weights</span></code>
argument. If no weights are set, the clauses are considered to be
hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  a list of new clauses to add.</p></li>
<li><p><strong>weights</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>)  a list of integer weights.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[3], [-4], [-5], [-6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 5, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressed_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_file" title="Link to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a file in the DIMACS format. A file name
is expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>
for parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>)  name of a file to parse.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
<li><p><strong>compressed_with</strong> (<em>str</em>)  file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf.bz2&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;bzip2&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.wcnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_fp" title="Link to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_string">
<span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_string" title="Link to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a string. The string should be specified
as an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string</strong> (<em>str</em>)  a string containing the formula in DIMACS.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s1">&#39;p wcnf 2 2 2</span><span class="se">\n</span><span class="s1"> 2 -1 2 0</span><span class="se">\n</span><span class="s1">1 1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1, 2]]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf 3 3 2</span><span class="se">\n</span><span class="s1">2 -1 2 0</span><span class="se">\n</span><span class="s1">2 -2 3 0</span><span class="se">\n</span><span class="s1">1 -3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.normalize_negatives">
<span class="sig-name descname"><span class="pre">normalize_negatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">negatives</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.normalize_negatives" title="Link to this definition">#</a></dt>
<dd><p>Iterate over all soft clauses with negative weights and add their
negation either as a hard clause or a soft one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>negatives</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>)  soft clauses with their negative weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_alien" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to dump a WCNF formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format lp, opb, or smt may be
specified (equal to opb by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>)  alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_dimacs" title="Link to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if some-file.cnf contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">wcnf</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span>
<span class="mi">2</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p wcnf 2 3 10</span>
<span class="go">10 1 2 0</span>
<span class="go">1 -1 0</span>
<span class="go">2 -2 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_file" title="Link to this definition">#</a></dt>
<dd><p>The method is for saving a WCNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>)  a file name where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
<li><p><strong>compress_with</strong> (<em>str</em>)  file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.wcnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_fp" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to save a WCNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">wcnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.unweighted">
<span class="sig-name descname"><span class="pre">unweighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.unweighted" title="Link to this definition">#</a></dt>
<dd><p>This method creates a <em>plain</em> (unweighted) copy of the internal
formula. As a result, an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> is returned.
Every clause (both hard or soft) of the WCNF formula is copied to
the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable of the resulting plain formula, i.e. all
weights are discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">unweighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6], [3], [-4], [-5], [-6]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">WCNFPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus" title="Link to this definition">#</a></dt>
<dd><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> assumes the
syntax of AtMostK and AtLeastK constraints following the one defined
for <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="p">(</span><span class="n">hard</span><span class="p">)</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">soft</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Additionally, <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> support pseudo-Boolean constraints,
i.e. weighted linear constraints by extending the above format.
Basically, a pseudo-Boolean constraint needs to specify all the
summands as <code class="docutils literal notranslate"><span class="pre">weight*literal</span></code> with the entire constraint being
prepended with character <code class="docutils literal notranslate"><span class="pre">w</span></code> as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">One</span> <span class="n">cardinality</span> <span class="n">constraint</span> <span class="ow">and</span> <span class="n">one</span> <span class="n">PB</span> <span class="n">constraint</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">soft</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="n">w</span> <span class="mi">1</span><span class="o">*</span><span class="mi">4</span> <span class="mi">2</span><span class="o">*</span><span class="mi">5</span> <span class="mi">1</span><span class="o">*</span><span class="mi">6</span> <span class="mi">3</span><span class="o">*-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p><strong>Note</strong> that every cardinality constraint is assumed to be <em>hard</em>,
i.e. soft cardinality constraints are currently <em>not supported</em>.</p>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK
constraints are stored in variable <code class="docutils literal notranslate"><span class="pre">atms</span></code>, each being a pair
<code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and
<code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf+ 7 3 10</span><span class="se">\n</span><span class="s1">10 1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">10 4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1">5 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_atmost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.append" title="Link to this definition">#</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to WCNF+
formula. This method additionally updates the number of variables,
i.e.  variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the clause can be either hard
or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code> argument. If no weight is
specified, the clause is considered hard. Otherwise, the clause is
soft.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>)  a new clause to add.</p></li>
<li><p><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>)  an integer weight of the clause.</p></li>
<li><p><strong>is_atmost</strong> (<em>bool</em>)  if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[1, 2, 3], 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[35]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.copy" title="Link to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a WCNFPlus object.
It creates another object of the <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> class, call the
copy function of WCNF class and makes use of the <em>deepcopy</em>
functionality to copy the atmost constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
<span class="go">&gt;&gt; print(cnf2.atms)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.from_fp" title="Link to this definition">#</a></dt>
<dd><p>Read a WCNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_alien" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to dump a WCNF+ formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format lp, opb, or smt may be
specified (equal to opb by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB2</a> does
not directly support PB constraints. As a result, native
cardinality constraints of CNF+ cannot be translated to
SMT-LIB2 unless an explicit cardinality encoding is applied.
You may want to use Z3s API instead (see its PB interface).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>)  alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_dimacs" title="Link to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if some-file.cnf contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p wcnf+ 7 4 10</span>
<span class="go">10 -1 3 5 0</span>
<span class="go">5 3 5 7 0</span>
<span class="go">10 1 -2 3 5 -7 &lt;= 3</span>
<span class="go">10 -4 -5 -6 7 &lt;= 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_fp" title="Link to this definition">#</a></dt>
<dd><p>The method can be used to save a WCNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>)  a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>)  additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.unweighted">
<span class="sig-name descname"><span class="pre">unweighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.unweighted" title="Link to this definition">#</a></dt>
<dd><p>This method creates a <em>plain</em> (unweighted) copy of the internal
formula. As a result, an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> is
returned. Every clause (both hard or soft) of the original
WCNFPlus formula is copied to the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable of the
resulting plain formula, i.e. all weights are discarded.</p>
<p>Note that the cardinality constraints of the original (weighted)
formula remain unchanged in the new (plain) formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">unweighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6], [3], [-4], [-5], [-6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.XOr">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">XOr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.XOr" title="Link to this definition">#</a></dt>
<dd><p>Exclusive disjunction. Given a list of operands (subformulas)
<span class="math notranslate nohighlight">\(f_i\)</span>, <span class="math notranslate nohighlight">\(i \in \{1,\ldots,n\}, n \in \mathbb{N}\)</span>, it
creates a formula <span class="math notranslate nohighlight">\(f_1 \oplus f_2 \oplus\ldots\oplus f_n\)</span>.
The list of operands <em>of size at least 2</em> should be passed as
arguments to the constructor.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xor</span> <span class="o">=</span> <span class="n">XOr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
</pre></div>
</div>
<p>If an additional Boolean keyword argument <code class="docutils literal notranslate"><span class="pre">merge</span></code> is provided set to
<code class="docutils literal notranslate"><span class="pre">True</span></code>, the toolkit will try to flatten the current <a class="reference internal" href="#pysat.formula.XOr" title="pysat.formula.XOr"><code class="xref py py-class docutils literal notranslate"><span class="pre">XOr</span></code></a>
formula merging its <em>equivalence</em> sub-operands into the list of
operands. For example, if <code class="docutils literal notranslate"><span class="pre">XOr(XOr(x,</span> <span class="pre">y),</span> <span class="pre">z,</span> <span class="pre">merge=True)</span></code> is called,
a new Formula object will be created with two operands: <code class="docutils literal notranslate"><span class="pre">XOr(x,</span> <span class="pre">y)</span></code>
and <code class="docutils literal notranslate"><span class="pre">z</span></code>, followed by merging <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> into the list of
root-level <code class="docutils literal notranslate"><span class="pre">XOr</span></code>. This will result in a formula <code class="docutils literal notranslate"><span class="pre">XOr(x,</span> <span class="pre">y,</span> <span class="pre">z)</span></code>.
Merging sub-operands is disabled by default if bitwise operations are
used to create <code class="docutils literal notranslate"><span class="pre">XOr</span></code> formulas.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">XOr</span><span class="p">(</span><span class="n">XOr</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a2</span> <span class="o">=</span> <span class="n">XOr</span><span class="p">(</span><span class="n">XOr</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">),</span> <span class="n">merge</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a3</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span> <span class="o">^</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">)</span> <span class="o">^</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>
<span class="go">(x ^ y) ^ z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">x ^ y ^ z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">(x ^ y) ^ z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">id</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
<span class="go">True  # formulas a1 and a3 refer to the same object</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If there are two formulas representing the same fact with and
without merging enabled, they technically sit in two distinct
objects. Although PySAT tries to avoid it, clausification of these
two formulas may result in unique (different) auxiliary variables
assigned to such two formulas.</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.XOr.simplified">
<span class="sig-name descname"><span class="pre">simplified</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">assumptions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.XOr.simplified" title="Link to this definition">#</a></dt>
<dd><p>Given a list of assumption literals, recursively simplifies the
subformulas and creates a new formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>assumptions</strong> (list(<a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a>))  atomic assumptions</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#pysat.formula.Formula" title="pysat.formula.Formula"><code class="xref py py-class docutils literal notranslate"><span class="pre">Formula</span></code></a></p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span> <span class="o">^</span> <span class="n">y</span> <span class="o">^</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="n">y</span><span class="p">]))</span>
<span class="go">~x ^ z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">simplified</span><span class="p">(</span><span class="n">assumptions</span><span class="o">=</span><span class="p">[</span><span class="o">~</span><span class="n">y</span><span class="p">]))</span>
<span class="go">x ^ z</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="card.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Cardinality encodings (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code>)</p>
      </div>
    </a>
    <a class="right-next"
       href="engines.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">External engines (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.engines</span></code>)</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <dialog id="pst-secondary-sidebar-modal"></dialog>
                <div id="pst-secondary-sidebar" class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
<div
    id="pst-page-navigation-heading-2"
    class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> On this page
  </div>
  <nav class="bd-toc-nav page-toc" aria-labelledby="pst-page-navigation-heading-2">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#list-of-classes">List of classes</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-description">Module description</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#module-details">Module details</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.And"><code class="docutils literal notranslate"><span class="pre">And</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.And.simplified"><code class="docutils literal notranslate"><span class="pre">And.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Atom"><code class="docutils literal notranslate"><span class="pre">Atom</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Atom.simplified"><code class="docutils literal notranslate"><span class="pre">Atom.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF"><code class="docutils literal notranslate"><span class="pre">CNF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.append"><code class="docutils literal notranslate"><span class="pre">CNF.append()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.copy"><code class="docutils literal notranslate"><span class="pre">CNF.copy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.extend"><code class="docutils literal notranslate"><span class="pre">CNF.extend()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.from_aiger"><code class="docutils literal notranslate"><span class="pre">CNF.from_aiger()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.from_clauses"><code class="docutils literal notranslate"><span class="pre">CNF.from_clauses()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.from_file"><code class="docutils literal notranslate"><span class="pre">CNF.from_file()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.from_fp"><code class="docutils literal notranslate"><span class="pre">CNF.from_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.from_string"><code class="docutils literal notranslate"><span class="pre">CNF.from_string()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.negate"><code class="docutils literal notranslate"><span class="pre">CNF.negate()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.simplified"><code class="docutils literal notranslate"><span class="pre">CNF.simplified()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.to_alien"><code class="docutils literal notranslate"><span class="pre">CNF.to_alien()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.to_dimacs"><code class="docutils literal notranslate"><span class="pre">CNF.to_dimacs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.to_file"><code class="docutils literal notranslate"><span class="pre">CNF.to_file()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.to_fp"><code class="docutils literal notranslate"><span class="pre">CNF.to_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNF.weighted"><code class="docutils literal notranslate"><span class="pre">CNF.weighted()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus"><code class="docutils literal notranslate"><span class="pre">CNFPlus</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.append"><code class="docutils literal notranslate"><span class="pre">CNFPlus.append()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.copy"><code class="docutils literal notranslate"><span class="pre">CNFPlus.copy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.extend"><code class="docutils literal notranslate"><span class="pre">CNFPlus.extend()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.from_fp"><code class="docutils literal notranslate"><span class="pre">CNFPlus.from_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.to_alien"><code class="docutils literal notranslate"><span class="pre">CNFPlus.to_alien()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.to_dimacs"><code class="docutils literal notranslate"><span class="pre">CNFPlus.to_dimacs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.to_fp"><code class="docutils literal notranslate"><span class="pre">CNFPlus.to_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.CNFPlus.weighted"><code class="docutils literal notranslate"><span class="pre">CNFPlus.weighted()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Equals"><code class="docutils literal notranslate"><span class="pre">Equals</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Equals.simplified"><code class="docutils literal notranslate"><span class="pre">Equals.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula"><code class="docutils literal notranslate"><span class="pre">Formula</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.atoms"><code class="docutils literal notranslate"><span class="pre">Formula.atoms()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.attach_vpool"><code class="docutils literal notranslate"><span class="pre">Formula.attach_vpool()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.clausify"><code class="docutils literal notranslate"><span class="pre">Formula.clausify()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.cleanup"><code class="docutils literal notranslate"><span class="pre">Formula.cleanup()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.export_vpool"><code class="docutils literal notranslate"><span class="pre">Formula.export_vpool()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.formulas"><code class="docutils literal notranslate"><span class="pre">Formula.formulas()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.literals"><code class="docutils literal notranslate"><span class="pre">Formula.literals()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.satisfied"><code class="docutils literal notranslate"><span class="pre">Formula.satisfied()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.set_context"><code class="docutils literal notranslate"><span class="pre">Formula.set_context()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Formula.simplified"><code class="docutils literal notranslate"><span class="pre">Formula.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.FormulaError"><code class="docutils literal notranslate"><span class="pre">FormulaError</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.FormulaType"><code class="docutils literal notranslate"><span class="pre">FormulaType</span></code></a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.IDPool"><code class="docutils literal notranslate"><span class="pre">IDPool</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.IDPool.id"><code class="docutils literal notranslate"><span class="pre">IDPool.id()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.IDPool.obj"><code class="docutils literal notranslate"><span class="pre">IDPool.obj()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.IDPool.occupy"><code class="docutils literal notranslate"><span class="pre">IDPool.occupy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.IDPool.restart"><code class="docutils literal notranslate"><span class="pre">IDPool.restart()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.ITE"><code class="docutils literal notranslate"><span class="pre">ITE</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.ITE.simplified"><code class="docutils literal notranslate"><span class="pre">ITE.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Implies"><code class="docutils literal notranslate"><span class="pre">Implies</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Implies.simplified"><code class="docutils literal notranslate"><span class="pre">Implies.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Neg"><code class="docutils literal notranslate"><span class="pre">Neg</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Neg.simplified"><code class="docutils literal notranslate"><span class="pre">Neg.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Or"><code class="docutils literal notranslate"><span class="pre">Or</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.Or.simplified"><code class="docutils literal notranslate"><span class="pre">Or.simplified()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF"><code class="docutils literal notranslate"><span class="pre">WCNF</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.append"><code class="docutils literal notranslate"><span class="pre">WCNF.append()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.copy"><code class="docutils literal notranslate"><span class="pre">WCNF.copy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.extend"><code class="docutils literal notranslate"><span class="pre">WCNF.extend()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.from_file"><code class="docutils literal notranslate"><span class="pre">WCNF.from_file()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.from_fp"><code class="docutils literal notranslate"><span class="pre">WCNF.from_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.from_string"><code class="docutils literal notranslate"><span class="pre">WCNF.from_string()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.normalize_negatives"><code class="docutils literal notranslate"><span class="pre">WCNF.normalize_negatives()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.to_alien"><code class="docutils literal notranslate"><span class="pre">WCNF.to_alien()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.to_dimacs"><code class="docutils literal notranslate"><span class="pre">WCNF.to_dimacs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.to_file"><code class="docutils literal notranslate"><span class="pre">WCNF.to_file()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.to_fp"><code class="docutils literal notranslate"><span class="pre">WCNF.to_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNF.unweighted"><code class="docutils literal notranslate"><span class="pre">WCNF.unweighted()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus"><code class="docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.append"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.append()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.copy"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.copy()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.from_fp"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.from_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.to_alien"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.to_alien()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.to_dimacs"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.to_dimacs()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.to_fp"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.to_fp()</span></code></a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.WCNFPlus.unweighted"><code class="docutils literal notranslate"><span class="pre">WCNFPlus.unweighted()</span></code></a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.XOr"><code class="docutils literal notranslate"><span class="pre">XOr</span></code></a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#pysat.formula.XOr.simplified"><code class="docutils literal notranslate"><span class="pre">XOr.simplified()</span></code></a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2018-2024, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>