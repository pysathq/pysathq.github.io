
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Boolean formula manipulation (pysat.formula) &#8212; PySAT 0.1.8.dev13 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Pseudo-Boolean encodings (pysat.pb)" href="pb.html" />
    <link rel="prev" title="Cardinality encodings (pysat.card)" href="card.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="https://pysathq.github.io">
  <img src="../_static/logo-dark.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <!-- This will display the version of the docs -->
<a href=https://pysathq.github.io/docs/html/index.html><strong>PySAT Documentation (version 0.1.8.dev13)</strong></a>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pysathq.github.io/docs/pysat.pdf" rel="noopener" target="_blank" title="PDF"><span><i class="fas fa-file"></i></span>
            <label class="sr-only">PDF</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat/issues" rel="noopener" target="_blank" title="Issue tracker"><span><i class="fas fa-bug"></i></span>
            <label class="sr-only">Issue tracker</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-description">
   Module description
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-details">
   Module details
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-pysat.formula">
<span id="boolean-formula-manipulation-pysat-formula"></span><h1>Boolean formula manipulation (<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a>)<a class="headerlink" href="#module-pysat.formula" title="Permalink to this headline">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">#</a></h2>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-obj docutils literal notranslate"><span class="pre">IDPool</span></code></a></p></td>
<td><p>A simple manager of variable IDs.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNF</span></code></a></p></td>
<td><p>Class for manipulating CNF formulas.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CNFPlus</span></code></a></p></td>
<td><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNF</span></code></a></p></td>
<td><p>Class for manipulating partial (weighted) CNF formulas.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-obj docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a></p></td>
<td><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">#</a></h2>
<p>This module is designed to facilitate fast and easy PySAT-development by
providing a simple way to manipulate formulas in PySAT. Although only
clausal formulas are supported at this point, future releases of PySAT are
expected to implement data structures and methods to manipulate arbitrary
Boolean formulas. The module implements the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class, which
represents a formula in <a class="reference external" href="https://en.wikipedia.org/wiki/Conjunctive_normal_form">conjunctive normal form (CNF)</a>.</p>
<p>Recall that a CNF formula is conventionally seen as a set of clauses, each
being a set of literals. A literal is a Boolean variable or its negation.
In PySAT, a Boolean variable and a literal should be specified as an
integer. For instance, a Boolean variable <span class="math notranslate nohighlight">\(x_{25}\)</span> is represented as
integer <code class="docutils literal notranslate"><span class="pre">25</span></code>. A literal <span class="math notranslate nohighlight">\(\neg{x_{10}}\)</span> should be specified as
<code class="docutils literal notranslate"><span class="pre">-10</span></code>. Moreover, a clause <span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span>
should be specified as <code class="docutils literal notranslate"><span class="pre">[-2,</span> <span class="pre">19,</span> <span class="pre">46]</span></code> in PySAT. <em>Unit size clauses</em> are
to be specified as unit size lists as well, e.g. a clause <span class="math notranslate nohighlight">\((x_3)\)</span> is
a list <code class="docutils literal notranslate"><span class="pre">[3]</span></code>.</p>
<p>CNF formulas can be created as an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>. For
instance, the following piece of code creates a CNF formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
</pre></div>
</div>
<p>The clauses of a formula can be accessed through the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable
of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>, which is a list of lists of integers:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2 ,3]]</span>
</pre></div>
</div>
<p>The number of variables in a CNF formula, i.e. the <em>largest variable
identifier</em>, can be obtained using the <code class="docutils literal notranslate"><span class="pre">nv</span></code> variable, e.g.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> has a few methods to read and write a CNF formula into a
file or a string. The formula is read/written in the standard <a class="reference external" href="https://en.wikipedia.org/wiki/Boolean_satisfiability_problem#SAT_problem_format">DIMACS CNF</a>
format. A clause in the DIMACS format is a string containing
space-separated integer literals  followed by <code class="docutils literal notranslate"><span class="pre">0</span></code>. For instance, a clause
<span class="math notranslate nohighlight">\((\neg{x_2}\vee x_{19}\vee x_{46})\)</span> is written as <code class="docutils literal notranslate"><span class="pre">-2</span> <span class="pre">19</span> <span class="pre">46</span> <span class="pre">0</span></code>
in DIMACS. The clauses in DIMACS should be preceded by a <em>preamble</em>, which
is a line <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span> <span class="pre">nof_variables</span> <span class="pre">nof_clauses</span></code>, where <code class="docutils literal notranslate"><span class="pre">nof_variables</span></code> and
<code class="docutils literal notranslate"><span class="pre">nof_clauses</span></code> are integers. A preamble line for formula
<span class="math notranslate nohighlight">\((\neg{x_1}\vee x_2)\wedge(\neg{x_2}\vee x_3)\)</span> would be <code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">cnf</span>
<span class="pre">3</span> <span class="pre">2</span></code>. The complete DIMACS file describing the formula looks this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">2</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Reading and writing formulas in DIMACS can be done with PySAT in the
following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># reading from file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f1</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;another-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">f2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># reading from a file pointer</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">fp</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">f2</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to a file pointer</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f3</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f3</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
<p>Besides plain CNF formulas, the <a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module implements an
additional class for dealing with <em>partial</em> and <em>weighted partial</em> CNF
formulas, i.e. WCNF formulas. A WCNF formula is a conjunction of two sets
of clauses: <em>hard</em> clauses and <em>soft</em> clauses, i.e.
<span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>. Soft clauses of a WCNF
are labeled with integer <em>weights</em>, i.e. a soft clause of
<span class="math notranslate nohighlight">\(\mathcal{S}\)</span> is a pair <span class="math notranslate nohighlight">\((c_i, w_i)\)</span>. In partial (unweighted)
formulas, all soft clauses have weight 1.</p>
<p>WCNF can be of help when solving optimization problems using the SAT
technology. A typical example of where a WCNF formula can be used is
<a class="reference external" href="https://en.wikipedia.org/wiki/Maximum_satisfiability_problem">maximum satisfiability (MaxSAT)</a>, which
given a WCNF formula <span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{H}\wedge\mathcal{S}\)</span>
targets satisfying all its hard clauses <span class="math notranslate nohighlight">\(\mathcal{H}\)</span> and maximizing
the sum of weights of satisfied soft clauses, i.e. maximizing the value of
<span class="math notranslate nohighlight">\(\sum_{c_i\in\mathcal{S}}{w_i\cdot c_i}\)</span>.</p>
<p>An object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> has two variables to access the hard and
soft clauses of the corresponding formula: <code class="docutils literal notranslate"><span class="pre">hard</span></code> and <code class="docutils literal notranslate"><span class="pre">soft</span></code>. The
weights of soft clauses are stored in variable <code class="docutils literal notranslate"><span class="pre">wght</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># the formula becomes unsatisfiable</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1], [2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 3]</span>
</pre></div>
</div>
<p>A properly constructed WCNF formula must have a <em>top weight</em>, which should
be equal to <span class="math notranslate nohighlight">\(1+\sum_{c_i\in\mathcal{S}}{w_i}\)</span>. Top weight of a
formula can be accessed through variable <code class="docutils literal notranslate"><span class="pre">topw</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># (1 + 3) + 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">topw</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Although it is not aligned with the WCNF format description, starting
with the 0.1.5.dev8 release, PySAT is able to deal with WCNF formulas
having not only integer clause weights but also weights represented as
<em>floating point numbers</em>. Moreover, <em>negative weights</em> are also
supported.</p>
</div>
<p>Additionally to classes <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>, the module provides
the extended classes <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>. The only
difference between <code class="docutils literal notranslate"><span class="pre">?CNF</span></code> and <code class="docutils literal notranslate"><span class="pre">?CNFPlus</span></code> is the support for <em>native</em>
cardinality constraints provided by the <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a> (see <a class="reference internal" href="card.html#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a> for
details). The corresponding variable in objects of <code class="docutils literal notranslate"><span class="pre">CNFPlus</span></code>
(<code class="docutils literal notranslate"><span class="pre">WCNFPlus</span></code>, resp.) responsible for storing the AtMostK constraints is
<code class="docutils literal notranslate"><span class="pre">atmosts</span></code> (<code class="docutils literal notranslate"><span class="pre">atms</span></code>, resp.). <strong>Note</strong> that at this point, AtMostK
constraints in <code class="docutils literal notranslate"><span class="pre">WCNF</span></code> can be <em>hard</em> only.</p>
<p>Besides the implementations of CNF and WCNF formulas in PySAT, the
<a class="reference internal" href="#module-pysat.formula" title="pysat.formula"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code></a> module also provides a way to manage variable
identifiers. This can be done with the use of the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> manager.
With the use of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> and <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> classes as well as with
the <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a> variable manager, it is pretty easy to develop
practical problem encoders into SAT or MaxSAT/MinSAT. As an example, a PHP
formula encoder is shown below (the implementation can also be found in
<a class="reference internal" href="examples/genhard.html#examples.genhard.PHP" title="examples.genhard.PHP"><code class="xref py py-class docutils literal notranslate"><span class="pre">examples.genhard.PHP</span></code></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>  <span class="c1"># we will store the formula here</span>

<span class="c1"># nof_holes is given</span>

<span class="c1"># initializing the pool of variable ids</span>
<span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">start_from</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">pigeon</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;pigeon</span><span class="si">{0}</span><span class="s1">@</span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

<span class="c1"># placing all pigeons into holes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>

<span class="c1"># there cannot be more than 1 pigeon in a hole</span>
<span class="n">pigeons</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nof_holes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">comb</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">pigeons</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="n">pigeon</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">comb</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.CNF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">CNF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_clauses</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_aiger</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF" title="Permalink to this definition">#</a></dt>
<dd><p>Class for manipulating CNF formulas. It can be used for creating
formulas, reading them from a file, or writing them to a file. The
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to parse
specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_file</strong> (<em>str</em>) – a DIMACS CNF filename to read from</p></li>
<li><p><strong>from_fp</strong> (<em>file_pointer</em>) – a file pointer to read from</p></li>
<li><p><strong>from_string</strong> (<em>str</em>) – a string storing a CNF formula</p></li>
<li><p><strong>from_clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses to bootstrap the formula with</p></li>
<li><p><strong>from_aiger</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> (see <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>)) – an AIGER circuit to bootstrap the formula with</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.append" title="Permalink to this definition">#</a></dt>
<dd><p>Add one more clause to CNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used
in the formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [3], [-3, 4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.copy" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a CNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy the clauses.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.extend" title="Permalink to this definition">#</a></dt>
<dd><p>Add several clauses to CNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.CNF.append" title="pysat.formula.CNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of new clauses to add.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [3], [-3, 4], [5, 6]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_aiger">
<span class="sig-name descname"><span class="pre">from_aiger</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">aig</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_aiger" title="Permalink to this definition">#</a></dt>
<dd><p>Create a CNF formula by Tseitin-encoding an input AIGER circuit.</p>
<p>Input circuit is expected to be an object of class
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code>. Alternatively, it can be specified as an
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.BoolExpr</span></code>, or an <code class="docutils literal notranslate"><span class="pre">*.aag</span></code> filename, or an AIGER
string to parse. (Classes <code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> and
<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.BoolExpr</span></code> are defined in the <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>.)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>aig</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">aiger.AIG</span></code> (see <a class="reference external" href="https://github.com/mvcisback/py-aiger">py-aiger package</a>)) – an input AIGER circuit</p></li>
<li><p><strong>vpool</strong> (<a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>) – pool of variable identifiers (optional)</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">aiger</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">),</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">),</span> <span class="n">aiger</span><span class="o">.</span><span class="n">atom</span><span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expr</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">x</span> <span class="o">|</span> <span class="n">y</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">aig</span><span class="p">)</span>
<span class="go">aag 5 3 0 1 2</span>
<span class="go">2</span>
<span class="go">4</span>
<span class="go">8</span>
<span class="go">10</span>
<span class="go">6 3 5</span>
<span class="go">10 6 8</span>
<span class="go">i0 y</span>
<span class="go">i1 x</span>
<span class="go">i2 z</span>
<span class="go">o0 6c454aea-c9e1-11e9-bbe3-3af9d34370a9</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_aiger</span><span class="o">=</span><span class="n">expr</span><span class="o">.</span><span class="n">aig</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[3, 2, 4], [-3, -4], [-2, -4], [-4, -1, 5], [4, -5], [1, -5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> &lt;-&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cnf</span><span class="o">.</span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnf</span><span class="o">.</span><span class="n">inps</span><span class="p">])</span>
<span class="go">[&#39;3 &lt;-&gt; y&#39;, &#39;2 &lt;-&gt; x&#39;, &#39;1 &lt;-&gt; z&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{0}</span><span class="s1"> &lt;-&gt; </span><span class="si">{1}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">cnf</span><span class="o">.</span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">cnf</span><span class="o">.</span><span class="n">outs</span><span class="p">])</span>
<span class="go">[&#39;5 &lt;-&gt; 6c454aea-c9e1-11e9-bbe3-3af9d34370a9&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_clauses">
<span class="sig-name descname"><span class="pre">from_clauses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_clauses" title="Permalink to this definition">#</a></dt>
<dd><p>This methods copies a list of clauses into a CNF object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of clauses</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1, -2], [5]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressed_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_file" title="Permalink to this definition">#</a></dt>
<dd><p>Read a CNF formula from a file in the DIMACS format. A file name is
expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> for
parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – name of a file to parse.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
<li><p><strong>compressed_with</strong> (<em>str</em>) – file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.cnf.gz&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;gzip&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_fp" title="Permalink to this definition">#</a></dt>
<dd><p>Read a CNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.from_string">
<span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.from_string" title="Permalink to this definition">#</a></dt>
<dd><p>Read a CNF formula from a string. The string should be specified as
an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string</strong> (<em>str</em>) – a string containing the formula in DIMACS.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s1">&#39;p cnf 2 2</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1, -2]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf 3 3</span><span class="se">\n</span><span class="s1">-1 2 0</span><span class="se">\n</span><span class="s1">-2 3 0</span><span class="se">\n</span><span class="s1">-3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3], [-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.negate">
<span class="sig-name descname"><span class="pre">negate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">topv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.negate" title="Permalink to this definition">#</a></dt>
<dd><p>Given a CNF formula <span class="math notranslate nohighlight">\(\mathcal{F}\)</span>, this method creates a CNF
formula <span class="math notranslate nohighlight">\(\neg{\mathcal{F}}\)</span>. The negation of the formula is
encoded to CNF with the use of <em>auxiliary</em> Tseitin variables <a class="footnote-reference brackets" href="#id2" id="id1">1</a>.
A new CNF formula is returned keeping all the newly introduced
variables that can be accessed through the <code class="docutils literal notranslate"><span class="pre">auxvars</span></code> variable.
All the literals used to encode the negation of the original
clauses can be accessed through the <code class="docutils literal notranslate"><span class="pre">enclits</span></code> variable.</p>
<p><strong>Note</strong> that the negation of each clause is encoded with one
auxiliary variable if it is not unit size. Otherwise, no auxiliary
variable is introduced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>topv</strong> (<em>int</em>) – top variable identifier if any.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>G. S. Tseitin. <em>On the complexity of derivations in the
propositional calculus</em>.  Studies in Mathematics and
Mathematical Logic, Part II. pp.  115–125, 1968</p>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pos</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">neg</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">negate</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[1, -4], [-2, -4], [-1, 2, 4], [4, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">auxvars</span><span class="p">)</span>
<span class="go">[4]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">neg</span><span class="o">.</span><span class="n">enclits</span><span class="p">)</span>  <span class="c1"># literals encoding the negation of clauses</span>
<span class="go">[4, -3]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_alien" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to dump a CNF formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format ‘lp’, ‘opb’, or ‘smt’ may be
specified (equal to ‘opb’ by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>) – alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_dimacs" title="Permalink to this definition">#</a></dt>
<dd><p>Return the current state of the object in DIMACS format.</p>
<p>For example, if ‘some-file.cnf’ contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">cnf</span> <span class="mi">3</span> <span class="mi">3</span>
<span class="o">-</span><span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">0</span>
<span class="o">-</span><span class="mi">3</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p cnf 3 3</span>
<span class="go">-1 2 0</span>
<span class="go">-2 3 0</span>
<span class="go">-3 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_file" title="Permalink to this definition">#</a></dt>
<dd><p>The method is for saving a CNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
<li><p><strong>compress_with</strong> (<em>str</em>) – file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.cnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.to_fp" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to save a CNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNF.weighted">
<span class="sig-name descname"><span class="pre">weighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNF.weighted" title="Permalink to this definition">#</a></dt>
<dd><p>This method creates a weighted copy of the internal formula. As a
result, an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> is returned. Every clause
of the CNF formula is <em>soft</em> in the new WCNF formula and its weight
is equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The set of hard clauses of the formula is empty.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNF</span><span class="p">(</span><span class="n">from_clauses</span><span class="o">=</span><span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">cnf</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, 2], [3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">CNFPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus" title="Permalink to this definition">#</a></dt>
<dd><p>CNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> assumes the syntax
of AtMostK and AtLeastK constraints defined in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK constraints
are stored in variable <code class="docutils literal notranslate"><span class="pre">atmosts</span></code>, each being a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and <code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper
bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p cnf+ 7 3</span><span class="se">\n</span><span class="s1">1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1"> 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_atmost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.append" title="Permalink to this definition">#</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to CNF+ formula.
This method additionally updates the number of variables, i.e.
variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</p></li>
<li><p><strong>is_atmost</strong> (<em>bool</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[1, 2, 3], 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.copy" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a CNFPlus object.
It creates another object of the <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> class, call the
copy function of CNF class and makes use of the <em>deepcopy</em>
functionality to copy the atmost constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, 2], [1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">formula</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.extend" title="Permalink to this definition">#</a></dt>
<dd><p>Extend the CNF+ formula with more clauses and/or AtMostK
constraints. The additional clauses and AtMostK constraints to add
should be given in the form of <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>. Alternatively, a
list of clauses can be added too. For every single clause and
AtMostK constraint in the input formula, method <a class="reference internal" href="#pysat.formula.CNFPlus.append" title="pysat.formula.CNFPlus.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is
invoked.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>formula</strong> (<a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>) – new constraints to add.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">cnf1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.from_fp" title="Permalink to this definition">#</a></dt>
<dd><p>Read a CNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_alien" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to dump a CNF+ formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format ‘lp’, ‘opb’, or ‘smt’ may be
specified (equal to ‘opb’ by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB2</a> does
not directly support PB constraints. As a result, native
cardinality constraints of CNF+ cannot be translated to
SMT-LIB2 unless an explicit cardinality encoding is applied.
You may want to use Z3’s API instead (see its PB interface).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>) – alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_dimacs" title="Permalink to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if ‘some-file.cnf’ contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">cnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p cnf+ 7 3</span>
<span class="go">3 5 7 0</span>
<span class="go">1 -2 3 5 -7 &lt;= 3</span>
<span class="go">-4 -5 -6 7 &lt;= 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.to_fp" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to save a CNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.CNFPlus.weighted">
<span class="sig-name descname"><span class="pre">weighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.CNFPlus.weighted" title="Permalink to this definition">#</a></dt>
<dd><p>This method creates a weighted copy of the internal formula. As a
result, an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> is returned. Every
clause of the CNFPlus formula is <em>soft</em> in the new WCNFPlus
formula and its weight is equal to <code class="docutils literal notranslate"><span class="pre">1</span></code>. The set of hard clauses
of the new formula is empty. The set of cardinality constraints
remains unchanged.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">CNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">cnf</span><span class="o">.</span><span class="n">weighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, 2], [3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">wcnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.IDPool">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">IDPool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_from</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool" title="Permalink to this definition">#</a></dt>
<dd><p>A simple manager of variable IDs. It can be used as a pool of integers
assigning an ID to any object. Identifiers are to start from <code class="docutils literal notranslate"><span class="pre">1</span></code> by
default. The list of occupied intervals is empty be default. If
necessary the top variable ID can be accessed directly using the
<code class="docutils literal notranslate"><span class="pre">top</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start_from</strong> (<em>int</em>) – the smallest ID to assign.</p></li>
<li><p><strong>occupied</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of occupied intervals.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.id">
<span class="sig-name descname"><span class="pre">id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.id" title="Permalink to this definition">#</a></dt>
<dd><p>The method is to be used to assign an integer variable ID for a
given new object. If the object already has an ID, no new ID is
created and the old one is returned instead.</p>
<p>An object can be anything. In some cases it is convenient to use
string variable names. Note that if the object is not provided,
the method will return a new id unassigned to any object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obj</strong> – an object to assign an ID to.</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">IDPool</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span> <span class="o">=</span> <span class="n">IDPool</span><span class="p">(</span><span class="n">occupied</span><span class="o">=</span><span class="p">[[</span><span class="mi">12</span><span class="p">,</span> <span class="mi">18</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># creating 5 unique variables for the following strings</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
<span class="gp">... </span>   <span class="nb">print</span><span class="p">(</span><span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;v</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">11</span>
<span class="go">19</span>
<span class="go">20</span>
</pre></div>
</div>
<p>In some cases, it makes sense to create an external function for
accessing IDPool, e.g.:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># continuing the previous example</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">vpool</span><span class="o">.</span><span class="n">id</span><span class="p">(</span><span class="s1">&#39;var</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="go">20</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">var</span><span class="p">(</span><span class="s1">&#39;hello_world!&#39;</span><span class="p">)</span>
<span class="go">21</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.obj">
<span class="sig-name descname"><span class="pre">obj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.obj" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to map back a given variable identifier to
the original object labeled by the identifier.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vid</strong> (<em>int</em>) – variable identifier.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>an object corresponding to the given identifier.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vpool</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>
<span class="go">&#39;hello_world!&#39;</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.occupy">
<span class="sig-name descname"><span class="pre">occupy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stop</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.occupy" title="Permalink to this definition">#</a></dt>
<dd><p>Mark a given interval as occupied so that the manager could skip
the values from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">stop</span></code> (<strong>inclusive</strong>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>start</strong> (<em>int</em>) – beginning of the interval.</p></li>
<li><p><strong>stop</strong> (<em>int</em>) – end of the interval.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.IDPool.restart">
<span class="sig-name descname"><span class="pre">restart</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_from</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">occupied</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.IDPool.restart" title="Permalink to this definition">#</a></dt>
<dd><p>Restart the manager from scratch. The arguments replicate those of
the constructor of <a class="reference internal" href="#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.WCNF">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">WCNF</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF" title="Permalink to this definition">#</a></dt>
<dd><p>Class for manipulating partial (weighted) CNF formulas. It can be used
for creating formulas, reading them from a file, or writing them to a
file. The <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code> parameter can be helpful when one needs to
parse specific comment lines starting not with character <code class="docutils literal notranslate"><span class="pre">c</span></code> but with
another character or a string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_file</strong> (<em>str</em>) – a DIMACS CNF filename to read from</p></li>
<li><p><strong>from_fp</strong> (<em>file_pointer</em>) – a file pointer to read from</p></li>
<li><p><strong>from_string</strong> (<em>str</em>) – a string storing a CNF formula</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.append" title="Permalink to this definition">#</a></dt>
<dd><p>Add one more clause to WCNF formula. This method additionally
updates the number of variables, i.e. variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in
the formula.</p>
<p>The clause can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code>
argument. If no weight is set, the clause is considered to be hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</p></li>
<li><p><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>) – integer weight of the clause.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1], [-2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10, 20]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.copy" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a WCNF object. It
creates another object of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a> class and makes use of
the <em>deepcopy</em> functionality to copy both hard and soft clauses.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clauses</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weights</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.extend" title="Permalink to this definition">#</a></dt>
<dd><p>Add several clauses to WCNF formula. The clauses should be given in
the form of list. For every clause in the list, method
<a class="reference internal" href="#pysat.formula.WCNF.append" title="pysat.formula.WCNF.append"><code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code></a> is invoked.</p>
<p>The clauses can be hard or soft depending on the <code class="docutils literal notranslate"><span class="pre">weights</span></code>
argument. If no weights are set, the clauses are considered to be
hard.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clauses</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – a list of new clauses to add.</p></li>
<li><p><strong>weights</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a list of integer weights.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[3], [-4], [-5], [-6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[1, 5, 3, 4]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_file">
<span class="sig-name descname"><span class="pre">from_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compressed_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_file" title="Permalink to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a file in the DIMACS format. A file name
is expected as an argument. A default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>
for parsing comment lines. A given file can be compressed by either
gzip, bzip2, or lzma.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – name of a file to parse.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
<li><p><strong>compressed_with</strong> (<em>str</em>) – file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compressed_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf.bz2&#39;</span><span class="p">,</span> <span class="n">compressed_with</span><span class="o">=</span><span class="s1">&#39;bzip2&#39;</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;another-file.wcnf&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_fp" title="Permalink to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.cnf&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.from_string">
<span class="sig-name descname"><span class="pre">from_string</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.from_string" title="Permalink to this definition">#</a></dt>
<dd><p>Read a WCNF formula from a string. The string should be specified
as an argument and should be in the DIMACS CNF format. The only
default argument is <code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing
specific comment lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>string</strong> (<em>str</em>) – a string containing the formula in DIMACS.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s1">&#39;p wcnf 2 2 2</span><span class="se">\n</span><span class="s1"> 2 -1 2 0</span><span class="se">\n</span><span class="s1">1 1 -2 0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf1</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1, 2]]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf 3 3 2</span><span class="se">\n</span><span class="s1">2 -1 2 0</span><span class="se">\n</span><span class="s1">2 -2 3 0</span><span class="se">\n</span><span class="s1">1 -3 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2], [-2, 3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.normalize_negatives">
<span class="sig-name descname"><span class="pre">normalize_negatives</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">negatives</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.normalize_negatives" title="Permalink to this definition">#</a></dt>
<dd><p>Iterate over all soft clauses with negative weights and add their
negation either as a hard clause or a soft one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>negatives</strong> (<em>list</em><em>(</em><em>list</em><em>(</em><em>int</em><em>)</em><em>)</em>) – soft clauses with their negative weights.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_alien" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to dump a WCNF formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format ‘lp’, ‘opb’, or ‘smt’ may be
specified (equal to ‘opb’ by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>) – alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_dimacs" title="Permalink to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if ‘some-file.cnf’ contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">wcnf</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">1</span> <span class="o">-</span><span class="mi">1</span> <span class="mi">0</span>
<span class="mi">2</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">0</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p wcnf 2 3 10</span>
<span class="go">10 1 2 0</span>
<span class="go">1 -1 0</span>
<span class="go">2 -2 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_file">
<span class="sig-name descname"><span class="pre">to_file</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress_with</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'use_ext'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_file" title="Permalink to this definition">#</a></dt>
<dd><p>The method is for saving a WCNF formula into a file in the DIMACS
CNF format. A file name is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter. Also, a file can be compressed using either gzip, bzip2,
or lzma (xz).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fname</strong> (<em>str</em>) – a file name where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
<li><p><strong>compress_with</strong> (<em>str</em>) – file compression algorithm</p></li>
</ul>
</dd>
</dl>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">compress_with</span></code> parameter can be <code class="docutils literal notranslate"><span class="pre">None</span></code> (i.e.
the file is uncompressed), <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bzip2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code>, or
<code class="docutils literal notranslate"><span class="pre">'use_ext'</span></code>. The latter value indicates that compression type
should be automatically determined based on the file extension.
Using <code class="docutils literal notranslate"><span class="pre">'lzma'</span></code> in Python 2 requires the <code class="docutils literal notranslate"><span class="pre">backports.lzma</span></code>
package to be additionally installed.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="s1">&#39;some-file-name.wcnf&#39;</span><span class="p">)</span>  <span class="c1"># writing to a file</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.to_fp" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to save a WCNF formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">wcnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNF.unweighted">
<span class="sig-name descname"><span class="pre">unweighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNF.unweighted" title="Permalink to this definition">#</a></dt>
<dd><p>This method creates a <em>plain</em> (unweighted) copy of the internal
formula. As a result, an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> is returned.
Every clause (both hard or soft) of the WCNF formula is copied to
the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable of the resulting plain formula, i.e. all
weights are discarded.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNF</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">unweighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6], [3], [-4], [-5], [-6]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.formula.</span></span><span class="sig-name descname"><span class="pre">WCNFPlus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_fp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_string</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus" title="Permalink to this definition">#</a></dt>
<dd><p>WCNF formulas augmented with <em>native</em> cardinality constraints.</p>
<p>This class inherits most of the functionality of the <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>
class. The only difference between the two is that <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>
supports <em>native</em> cardinality constraints of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a>.</p>
<p>The parser of input DIMACS files of <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> assumes the
syntax of AtMostK and AtLeastK constraints following the one defined
for <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> in the <a class="reference external" href="https://github.com/liffiton/minicard">description</a> of MiniCard:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span><span class="p">:</span> <span class="n">Two</span> <span class="p">(</span><span class="n">hard</span><span class="p">)</span> <span class="n">cardinality</span> <span class="n">constraints</span> <span class="n">followed</span> <span class="n">by</span> <span class="n">a</span> <span class="n">soft</span> <span class="n">clause</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p><strong>Note</strong> that every cardinality constraint is assumed to be <em>hard</em>,
i.e. soft cardinality constraints are currently <em>not supported</em>.</p>
<p>Each AtLeastK constraint is translated into an AtMostK constraint in
the standard way: <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k \leftrightarrow
\sum_{i=1}^{n}{\neg{x_i}}\leq (n-k)\)</span>. Internally, AtMostK constraints
are stored in variable <code class="docutils literal notranslate"><span class="pre">atms</span></code>, each being a pair <code class="docutils literal notranslate"><span class="pre">(lits,</span> <span class="pre">k)</span></code>, where
<code class="docutils literal notranslate"><span class="pre">lits</span></code> is a list of literals in the sum and <code class="docutils literal notranslate"><span class="pre">k</span></code> is the upper bound.</p>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_string</span><span class="o">=</span><span class="s1">&#39;p wcnf+ 7 3 10</span><span class="se">\n</span><span class="s1">10 1 -2 3 5 -7 &lt;= 3</span><span class="se">\n</span><span class="s1">10 4 5 6 -7 &gt;= 2</span><span class="se">\n</span><span class="s1">5 3 5 7 0</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[3, 5, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[5]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[[1, -2, 3, 5, -7], 3], [[-4, -5, -6, 7], 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>For details on the functionality, see <a class="reference internal" href="#pysat.formula.WCNF" title="pysat.formula.WCNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNF</span></code></a>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clause</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_atmost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.append" title="Permalink to this definition">#</a></dt>
<dd><p>Add a single clause or a single AtMostK constraint to WCNF+
formula. This method additionally updates the number of variables,
i.e.  variable <code class="docutils literal notranslate"><span class="pre">self.nv</span></code>, used in the formula.</p>
<p>If the clause is an AtMostK constraint, this should be set with the
use of the additional default argument <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code>, which is set
to <code class="docutils literal notranslate"><span class="pre">False</span></code> by default.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">is_atmost</span></code> is set to <code class="docutils literal notranslate"><span class="pre">False</span></code>, the clause can be either hard
or soft depending on the <code class="docutils literal notranslate"><span class="pre">weight</span></code> argument. If no weight is
specified, the clause is considered hard. Otherwise, the clause is
soft.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clause</strong> (<em>list</em><em>(</em><em>int</em><em>)</em>) – a new clause to add.</p></li>
<li><p><strong>weight</strong> (<em>integer</em><em> or </em><em>None</em>) – an integer weight of the clause.</p></li>
<li><p><strong>is_atmost</strong> (<em>bool</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code>, the clause is AtMostK.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">35</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-3, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atms</span><span class="p">)</span>
<span class="go">[[1, 2, 3], 1]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[-1, -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[35]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.copy" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a copy of a WCNFPlus object.
It creates another object of the <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a> class, call the
copy function of WCNF class and makes use of the <em>deepcopy</em>
functionality to copy the atmost constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.WCNFPlus" title="pysat.formula.WCNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">WCNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf1</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf2</span> <span class="o">=</span> <span class="n">cnf1</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">hard</span><span class="p">)</span>
<span class="go">[[-1, 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">soft</span><span class="p">)</span>
<span class="go">[[1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">wght</span><span class="p">)</span>
<span class="go">[10]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf2</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span>
<span class="go">2</span>
<span class="go">&gt;&gt; print(cnf2.atms)</span>
<span class="go">[[[1, 2], 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.from_fp">
<span class="sig-name descname"><span class="pre">from_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comment_lead</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">['c']</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.from_fp" title="Permalink to this definition">#</a></dt>
<dd><p>Read a WCNF+ formula from a file pointer. A file pointer should be
specified as an argument. The only default argument is
<code class="docutils literal notranslate"><span class="pre">comment_lead</span></code>, which can be used for parsing specific comment
lines.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer to read the formula from.</p></li>
<li><p><strong>comment_lead</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – a list of characters leading comment lines</p></li>
</ul>
</dd>
</dl>
<p>Usage example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf1</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">... </span>    <span class="n">cnf1</span><span class="o">.</span><span class="n">from_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;another-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf2</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_fp</span><span class="o">=</span><span class="n">fp</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_alien">
<span class="sig-name descname"><span class="pre">to_alien</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'opb'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_alien" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to dump a WCNF+ formula into a file pointer
in an alien file format, which at this point can either be LP,
OPB, or SMT. The file pointer is expected as an argument.
Additionally, the target format ‘lp’, ‘opb’, or ‘smt’ may be
specified (equal to ‘opb’ by default). Finally, supplementary
comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code> parameter.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="http://smtlib.cs.uiowa.edu/language.shtml">SMT-LIB2</a> does
not directly support PB constraints. As a result, native
cardinality constraints of CNF+ cannot be translated to
SMT-LIB2 unless an explicit cardinality encoding is applied.
You may want to use Z3’s API instead (see its PB interface).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>format</strong> (<em>str</em>) – alien file format to use</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.lp&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_alien</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;lp&#39;</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_dimacs">
<span class="sig-name descname"><span class="pre">to_dimacs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_dimacs" title="Permalink to this definition">#</a></dt>
<dd><p>Return the current state of the object in extended DIMACS format.</p>
<p>For example, if ‘some-file.cnf’ contains:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">Example</span>
<span class="n">p</span> <span class="n">wcnf</span><span class="o">+</span> <span class="mi">7</span> <span class="mi">3</span> <span class="mi">10</span>
<span class="mi">10</span> <span class="mi">1</span> <span class="o">-</span><span class="mi">2</span> <span class="mi">3</span> <span class="mi">5</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&lt;=</span> <span class="mi">3</span>
<span class="mi">10</span> <span class="mi">4</span> <span class="mi">5</span> <span class="mi">6</span> <span class="o">-</span><span class="mi">7</span> <span class="o">&gt;=</span> <span class="mi">2</span>
<span class="mi">5</span> <span class="mi">3</span> <span class="mi">5</span> <span class="mi">7</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Then you can obtain the DIMACS with:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">(</span><span class="n">from_file</span><span class="o">=</span><span class="s1">&#39;some-file.cnf&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">to_dimacs</span><span class="p">())</span>
<span class="go">c Example</span>
<span class="go">p wcnf+ 7 4 10</span>
<span class="go">10 -1 3 5 0</span>
<span class="go">5 3 5 7 0</span>
<span class="go">10 1 -2 3 5 -7 &lt;= 3</span>
<span class="go">10 -4 -5 -6 7 &lt;= 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.to_fp">
<span class="sig-name descname"><span class="pre">to_fp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_pointer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.to_fp" title="Permalink to this definition">#</a></dt>
<dd><p>The method can be used to save a WCNF+ formula into a file pointer.
The file pointer is expected as an argument. Additionally,
supplementary comment lines can be specified in the <code class="docutils literal notranslate"><span class="pre">comments</span></code>
parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_pointer</strong> (<em>file pointer</em>) – a file pointer where to store the formula.</p></li>
<li><p><strong>comments</strong> (<em>list</em><em>(</em><em>str</em><em>)</em>) – additional comments to put in the file.</p></li>
</ul>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNFPlus</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">...</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># the formula is filled with a bunch of clauses</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;some-file.wcnf+&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">cnf</span><span class="o">.</span><span class="n">to_fp</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>  <span class="c1"># writing to the file pointer</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.formula.WCNFPlus.unweighted">
<span class="sig-name descname"><span class="pre">unweighted</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.formula.WCNFPlus.unweighted" title="Permalink to this definition">#</a></dt>
<dd><p>This method creates a <em>plain</em> (unweighted) copy of the internal
formula. As a result, an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> is
returned. Every clause (both hard or soft) of the original
WCNFPlus formula is copied to the <code class="docutils literal notranslate"><span class="pre">clauses</span></code> variable of the
resulting plain formula, i.e. all weights are discarded.</p>
<p>Note that the cardinality constraints of the original (weighted)
formula remain unchanged in the new (plain) formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an object of class <a class="reference internal" href="#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a>.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.formula</span> <span class="kn">import</span> <span class="n">WCNF</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span> <span class="o">=</span> <span class="n">WCNFPlus</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">extend</span><span class="p">([[</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">6</span><span class="p">]],</span> <span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wcnf</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">is_atmost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">wcnf</span><span class="o">.</span><span class="n">unweighted</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-3, 4], [5, 6], [3], [-4], [-5], [-6]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">atmosts</span><span class="p">)</span>
<span class="go">[[[1, 2, 3], 1]]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="card.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Cardinality encodings (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code>)</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="pb.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Pseudo-Boolean encodings (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.pb</span></code>)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018-2022, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>