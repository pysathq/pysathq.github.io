
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Cardinality encodings (pysat.card) &#8212; PySAT 1.8.dev2 documentation</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Boolean formula manipulation (pysat.formula)" href="formula.html" />
    <link rel="prev" title="Welcome to PySAT’s documentation!" href="../index.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    

<a class="navbar-brand" href="https://pysathq.github.io">
  <img src="../_static/logo-dark.svg" class="logo" alt="logo">
</a>


    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <!-- This will display the version of the docs -->
<a href=https://pysathq.github.io/docs/html/index.html><strong>PySAT Documentation (version 1.8.dev2)</strong></a>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat" rel="noopener" target="_blank" title="GitHub"><span><i class="fab fa-github-square"></i></span>
            <label class="sr-only">GitHub</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://pysathq.github.io/docs/pysat.pdf" rel="noopener" target="_blank" title="PDF"><span><i class="fas fa-file"></i></span>
            <label class="sr-only">PDF</label></a>
        </li>
        <li class="nav-item">
          <a class="nav-link" href="https://github.com/pysathq/pysat/issues" rel="noopener" target="_blank" title="Issue tracker"><span><i class="fas fa-bug"></i></span>
            <label class="sr-only">Issue tracker</label></a>
        </li>
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar">
              <div class="sidebar-start-items"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
              </div>
              <div class="sidebar-end-items">
              </div>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage mt-5 pt-1 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#list-of-classes">
   List of classes
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-description">
   Module description
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#module-details">
   Module details
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="module-pysat.card">
<span id="cardinality-encodings-pysat-card"></span><h1>Cardinality encodings (<a class="reference internal" href="#module-pysat.card" title="pysat.card"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.card</span></code></a>)<a class="headerlink" href="#module-pysat.card" title="Permalink to this headline">#</a></h1>
<section id="list-of-classes">
<h2>List of classes<a class="headerlink" href="#list-of-classes" title="Permalink to this headline">#</a></h2>
<table class="autosummary longtable table autosummary">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-obj docutils literal notranslate"><span class="pre">EncType</span></code></a></p></td>
<td><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the cardinality encoding to use.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CardEnc</span></code></a></p></td>
<td><p>This abstract class is responsible for the creation of cardinality constraints encoded to a CNF formula.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ITotalizer</span></code></a></p></td>
<td><p>This class implements the iterative totalizer encoding <a class="footnote-reference brackets" href="#id24" id="id1">11</a>.</p></td>
</tr>
</tbody>
</table>
</section>
<section id="module-description">
<h2>Module description<a class="headerlink" href="#module-description" title="Permalink to this headline">#</a></h2>
<p>This module provides access to various <em>cardinality constraint</em> <a class="footnote-reference brackets" href="#id13" id="id2">1</a>
encodings to formulas in conjunctive normal form (CNF). These include
pairwise <a class="footnote-reference brackets" href="#id14" id="id3">2</a>, bitwise <a class="footnote-reference brackets" href="#id14" id="id4">2</a>, ladder/regular <a class="footnote-reference brackets" href="#id15" id="id5">3</a> <a class="footnote-reference brackets" href="#id16" id="id6">4</a>, sequential counters
<a class="footnote-reference brackets" href="#id17" id="id7">5</a>, sorting <a class="footnote-reference brackets" href="#id18" id="id8">6</a> and cardinality networks <a class="footnote-reference brackets" href="#id19" id="id9">7</a>, totalizer <a class="footnote-reference brackets" href="#id20" id="id10">8</a>, modulo
totalizer <a class="footnote-reference brackets" href="#id21" id="id11">9</a>, and modulo totalizer for <span class="math notranslate nohighlight">\(k\)</span>-cardinality <a class="footnote-reference brackets" href="#id22" id="id12">10</a>, as
well as a <em>native</em> cardinality constraint representation supported by the
<a class="reference external" href="https://github.com/liffiton/minicard">MiniCard solver</a>.</p>
<dl class="footnote brackets">
<dt class="label" id="id13"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p>Olivier Roussel, Vasco M. Manquinho. <em>Pseudo-Boolean and Cardinality
Constraints</em>. Handbook of Satisfiability.  2009. pp. 695-733</p>
</dd>
<dt class="label" id="id14"><span class="brackets">2</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id4">2</a>)</span></dt>
<dd><p>Steven David Prestwich. <em>CNF Encodings</em>. Handbook of Satisfiability.
2009. pp. 75-97</p>
</dd>
<dt class="label" id="id15"><span class="brackets"><a class="fn-backref" href="#id5">3</a></span></dt>
<dd><p>Carlos Ansótegui, Felip Manyà. <em>Mapping Problems with Finite-Domain
Variables to Problems with Boolean Variables</em>. SAT (Selected Papers)
2004. pp. 1-15</p>
</dd>
<dt class="label" id="id16"><span class="brackets"><a class="fn-backref" href="#id6">4</a></span></dt>
<dd><p>Ian P. Gent, Peter Nightingale. <em>A New Encoding of Alldifferent Into
SAT</em>. In International workshop on modelling and reformulating
constraint satisfaction problems 2004. pp. 95-110</p>
</dd>
<dt class="label" id="id17"><span class="brackets"><a class="fn-backref" href="#id7">5</a></span></dt>
<dd><p>Carsten Sinz. <em>Towards an Optimal CNF Encoding of Boolean
Cardinality Constraints</em>. CP 2005. pp. 827-831</p>
</dd>
<dt class="label" id="id18"><span class="brackets"><a class="fn-backref" href="#id8">6</a></span></dt>
<dd><p>Kenneth E. Batcher. <em>Sorting Networks and Their Applications</em>.
AFIPS Spring Joint Computing Conference 1968. pp. 307-314</p>
</dd>
<dt class="label" id="id19"><span class="brackets"><a class="fn-backref" href="#id9">7</a></span></dt>
<dd><p>Roberto Asin, Robert Nieuwenhuis, Albert Oliveras,
Enric Rodriguez-Carbonell. <em>Cardinality Networks and Their
Applications</em>. SAT 2009. pp. 167-180</p>
</dd>
<dt class="label" id="id20"><span class="brackets"><a class="fn-backref" href="#id10">8</a></span></dt>
<dd><p>Olivier Bailleux, Yacine Boufkhad. <em>Efficient CNF Encoding of
Boolean Cardinality Constraints</em>. CP 2003. pp. 108-122</p>
</dd>
<dt class="label" id="id21"><span class="brackets"><a class="fn-backref" href="#id11">9</a></span></dt>
<dd><p>Toru Ogawa, Yangyang Liu, Ryuzo Hasegawa, Miyuki Koshimura,
Hiroshi Fujita. <em>Modulo Based CNF Encoding of Cardinality Constraints
and Its Application to MaxSAT Solvers</em>. ICTAI 2013. pp. 9-17</p>
</dd>
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id12">10</a></span></dt>
<dd><p>António Morgado, Alexey Ignatiev, Joao Marques-Silva. <em>MSCG: Robust
Core-Guided MaxSAT Solving</em>. System Description. JSAT 2015. vol. 9,
pp. 129-134</p>
</dd>
</dl>
<p>A cardinality constraint is a constraint of the form:
<span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq k\)</span>. Cardinality constraints are ubiquitous in
practical problem formulations. Note that the implementation of the
pairwise, bitwise, and ladder encodings can only deal with AtMost1
constraints, e.g. <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i}\leq 1\)</span>.</p>
<p>Access to all cardinality encodings can be made through the main class of
this module, which is <a class="reference internal" href="#pysat.card.CardEnc" title="pysat.card.CardEnc"><code class="xref py py-class docutils literal notranslate"><span class="pre">CardEnc</span></code></a>.</p>
<p>Additionally, to the standard cardinality encodings that are basically
“static” CNF formulas, the module is designed to able to construct
<em>incremental</em> cardinality encodings, i.e. those that can be incrementally
extended at a later stage. At this point only the <em>iterative totalizer</em>
<a class="footnote-reference brackets" href="#id24" id="id23">11</a> encoding is supported. Iterative totalizer can be accessed with the
use of the <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> class.</p>
<dl class="footnote brackets">
<dt class="label" id="id24"><span class="brackets">11</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id23">2</a>,<a href="#id25">3</a>)</span></dt>
<dd><p>Ruben Martins, Saurabh Joshi, Vasco M. Manquinho, Inês Lynce.
<em>Incremental Cardinality Constraints for MaxSAT</em>. CP 2014. pp. 531-548</p>
</dd>
</dl>
</section>
<section id="module-details">
<h2>Module details<a class="headerlink" href="#module-details" title="Permalink to this headline">#</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="pysat.card.CardEnc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.card.</span></span><span class="sig-name descname"><span class="pre">CardEnc</span></span><a class="headerlink" href="#pysat.card.CardEnc" title="Permalink to this definition">#</a></dt>
<dd><p>This abstract class is responsible for the creation of cardinality
constraints encoded to a CNF formula. The class has three <em>class
methods</em> for creating AtMostK, AtLeastK, and EqualsK constraints. Given
a list of literals, an integer bound and an encoding type, each of
these methods returns an object of class <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">pysat.formula.CNFPlus</span></code></a>
representing the resulting CNF formula.</p>
<p>Since the class is abstract, there is no need to create an object of
it. Instead, the methods should be called directly as class methods,
e.g. <code class="docutils literal notranslate"><span class="pre">CardEnc.atmost(lits,</span> <span class="pre">bound)</span></code> or <code class="docutils literal notranslate"><span class="pre">CardEnc.equals(lits,</span>
<span class="pre">bound)</span></code>. An example usage is the following:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="o">*</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">atmost</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-1, -2], [-1, -3], [-2, -3]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cnf</span> <span class="o">=</span> <span class="n">CardEnc</span><span class="o">.</span><span class="n">equals</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="n">EncType</span><span class="o">.</span><span class="n">pairwise</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[1, 2, 3], [-1, -2], [-1, -3], [-2, -3]]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.CardEnc.atleast">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">atleast</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atleast" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtLeastK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\geq k\)</span>. The method
takes 1 mandatory argument <code class="docutils literal notranslate"><span class="pre">lits</span></code> and 3 default arguments can be
specified: <code class="docutils literal notranslate"><span class="pre">bound</span></code>, <code class="docutils literal notranslate"><span class="pre">top_id</span></code>, <code class="docutils literal notranslate"><span class="pre">vpool</span></code>, and <code class="docutils literal notranslate"><span class="pre">encoding</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals in the sum.</p></li>
<li><p><strong>bound</strong> (<em>int</em>) – the value of bound <span class="math notranslate nohighlight">\(k\)</span>.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</p></li>
<li><p><strong>vpool</strong> (<a class="reference internal" href="formula.html#pysat.formula.IDPool" title="pysat.formula.IDPool"><code class="xref py py-class docutils literal notranslate"><span class="pre">IDPool</span></code></a>) – variable pool for counting the number of variables.</p></li>
<li><p><strong>encoding</strong> (<em>integer</em>) – identifier of the encoding to use.</p></li>
</ul>
</dd>
</dl>
<p>Parameter <code class="docutils literal notranslate"><span class="pre">top_id</span></code> serves to increase integer identifiers of
auxiliary variables introduced during the encoding process. This
is helpful when augmenting an existing CNF formula with the new
cardinality encoding to make sure there is no collision between
identifiers of the variables. If specified, the identifiers of the
first auxiliary variable will be <code class="docutils literal notranslate"><span class="pre">top_id+1</span></code>.</p>
<p>Instead of <code class="docutils literal notranslate"><span class="pre">top_id</span></code>, one may want to use a pool of variable
identifiers <code class="docutils literal notranslate"><span class="pre">vpool</span></code>, which is automatically updated during the
method call. In many circumstances, this is more convenient than
using <code class="docutils literal notranslate"><span class="pre">top_id</span></code>. Also note that parameters <code class="docutils literal notranslate"><span class="pre">top_id</span></code> and
<code class="docutils literal notranslate"><span class="pre">vpool</span></code> <strong>cannot</strong> be specified <em>simultaneously</em>.</p>
<p>The default value of <code class="docutils literal notranslate"><span class="pre">encoding</span></code> is <code class="xref py py-attr docutils literal notranslate"><span class="pre">Enctype.seqcounter</span></code>.</p>
<p>The method <em>translates</em> the AtLeast constraint into an AtMost
constraint by <em>negating</em> the literals of <code class="docutils literal notranslate"><span class="pre">lits</span></code>, creating a new
bound <span class="math notranslate nohighlight">\(n-k\)</span> and invoking <a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a> with the
modified list of literals and the new bound.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>CardEnc.NoSuchEncodingError</strong> – if encoding does not exist.</p></li>
<li><p><strong>ValueError</strong> – if bound is meaningless for encoding.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>a <a class="reference internal" href="formula.html#pysat.formula.CNFPlus" title="pysat.formula.CNFPlus"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNFPlus</span></code></a> object where the new             clauses (or the new native atmost constraint) are stored.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.CardEnc.atmost">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">atmost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.atmost" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an AtMostK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}\leq k\)</span>. The method
shares the arguments and the return type with method
<a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.CardEnc.equals">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">equals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vpool</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.CardEnc.equals" title="Permalink to this definition">#</a></dt>
<dd><p>This method can be used for creating a CNF encoding of an EqualsK
constraint, i.e. of <span class="math notranslate nohighlight">\(\sum_{i=1}^{n}{x_i}= k\)</span>. The method
makes consecutive calls of both <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a> and
<a class="reference internal" href="#pysat.card.CardEnc.atmost" title="pysat.card.CardEnc.atmost"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atmost()</span></code></a>. It shares the arguments and the return type
with method <a class="reference internal" href="#pysat.card.CardEnc.atleast" title="pysat.card.CardEnc.atleast"><code class="xref py py-meth docutils literal notranslate"><span class="pre">CardEnc.atleast()</span></code></a>. Please, see it for details.</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.card.EncType">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.card.</span></span><span class="sig-name descname"><span class="pre">EncType</span></span><a class="headerlink" href="#pysat.card.EncType" title="Permalink to this definition">#</a></dt>
<dd><p>This class represents a C-like <code class="docutils literal notranslate"><span class="pre">enum</span></code> type for choosing the
cardinality encoding to use. The values denoting the encodings are:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pairwise</span>    <span class="o">=</span> <span class="mi">0</span>
<span class="n">seqcounter</span>  <span class="o">=</span> <span class="mi">1</span>
<span class="n">sortnetwrk</span>  <span class="o">=</span> <span class="mi">2</span>
<span class="n">cardnetwrk</span>  <span class="o">=</span> <span class="mi">3</span>
<span class="n">bitwise</span>     <span class="o">=</span> <span class="mi">4</span>
<span class="n">ladder</span>      <span class="o">=</span> <span class="mi">5</span>
<span class="n">totalizer</span>   <span class="o">=</span> <span class="mi">6</span>
<span class="n">mtotalizer</span>  <span class="o">=</span> <span class="mi">7</span>
<span class="n">kmtotalizer</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">native</span>      <span class="o">=</span> <span class="mi">9</span>
</pre></div>
</div>
<p>The desired encoding can be selected either directly by its integer
identifier, e.g. <code class="docutils literal notranslate"><span class="pre">2</span></code>, or by its alphabetical name, e.g.
<code class="docutils literal notranslate"><span class="pre">EncType.sortnetwrk</span></code>.</p>
<p>Note that while most of the encodings are produced as a list of
clauses, the “native” encoding of <a class="reference external" href="https://github.com/liffiton/minicard">MiniCard</a> is managed as one clause.
Given an AtMostK constraint <span class="math notranslate nohighlight">\(\sum_{i=1}^n{x_i\leq k}\)</span>, the native
encoding represents it as a pair <code class="docutils literal notranslate"><span class="pre">[lits,</span> <span class="pre">k]</span></code>, where <code class="docutils literal notranslate"><span class="pre">lits</span></code> is a
list of size <code class="docutils literal notranslate"><span class="pre">n</span></code> containing literals in the sum.</p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pysat.card.ITotalizer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.card.</span></span><span class="sig-name descname"><span class="pre">ITotalizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer" title="Permalink to this definition">#</a></dt>
<dd><p>This class implements the iterative totalizer encoding <a class="footnote-reference brackets" href="#id24" id="id25">11</a>. Note that
<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> can be used only for creating AtMostK constraints.
In contrast to class <a class="reference internal" href="#pysat.card.EncType" title="pysat.card.EncType"><code class="xref py py-class docutils literal notranslate"><span class="pre">EncType</span></code></a>, this class is not abstract and
its objects once created can be reused several times. The idea is that
a <em>totalizer tree</em> can be extended, or the bound can be increased, as
well as two totalizer trees can be merged into one.</p>
<p>The constructor of the class object takes 3 default arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – a list of literals to sum.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – the largest potential bound to use.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – top variable identifier used so far.</p></li>
</ul>
</dd>
</dl>
<p>The encoding of the current tree can be accessed with the use of
<a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> variable stored as <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. Potential bounds <strong>are
not</strong> imposed by default but can be added as unit clauses in the final
CNF formula. The bounds are stored in the list of Boolean variables as
<code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>. A concrete bound <span class="math notranslate nohighlight">\(k\)</span> can be enforced by considering
a unit clause <code class="docutils literal notranslate"><span class="pre">-self.rhs[k]</span></code>. <strong>Note</strong> that <code class="docutils literal notranslate"><span class="pre">-self.rhs[0]</span></code> enforces
all literals of the sum to be <em>false</em>.</p>
<p>An <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object should be deleted if it is not needed
anymore.</p>
<p>Possible usage of the class is shown below:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>Alternatively, an object can be created using the <code class="docutils literal notranslate"><span class="pre">with</span></code> keyword. In
this case, the object is deleted automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.ITotalizer.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.delete" title="Permalink to this definition">#</a></dt>
<dd><p>Destroys a previously constructed <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object.
Internal variables <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code> and <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> get cleaned.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.ITotalizer.extend">
<span class="sig-name descname"><span class="pre">extend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.extend" title="Permalink to this definition">#</a></dt>
<dd><p>Extends the list of literals in the sum and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lits</strong> (<em>iterable</em><em>(</em><em>int</em><em>)</em>) – additional literals to be included in the sum.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree augmented with new literals in the sum and updating
the upper bound. As a result, it appends the new clauses to the
list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of newly
created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[3, 4]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-5, 6], [-3, 6], [-4, 7], [-3, -5, 7], [-4, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.ITotalizer.increase">
<span class="sig-name descname"><span class="pre">increase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.increase" title="Permalink to this definition">#</a></dt>
<dd><p>Increases a potential upper bound that can be imposed on the
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree up to the new upper bound given and appends them to
the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The number of
newly created clauses is stored in variable <code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code> gets increased and its length
becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7]</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">increase</span><span class="p">(</span><span class="n">ubound</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 4], [-1, 4], [-1, -2, 5], [-4, 6], [-5, 7], [-3, 6], [-3, -4, 7], [-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-3, -5, 8]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[6, 7, 8]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">t</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.ITotalizer.merge_with">
<span class="sig-name descname"><span class="pre">merge_with</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">another</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.merge_with" title="Permalink to this definition">#</a></dt>
<dd><p>This method merges a tree of the current <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>
object, with a tree of another object and (if needed) increases a
potential upper bound that can be imposed on the complete list of
literals in the sum of an existing <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> object to a
new value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>another</strong> (<a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>) – another totalizer to merge with.</p></li>
<li><p><strong>ubound</strong> (<em>int</em>) – a new upper bound.</p></li>
<li><p><strong>top_id</strong> (<em>integer</em><em> or </em><em>None</em>) – a new top variable identifier.</p></li>
</ul>
</dd>
</dl>
<p>The top identifier <code class="docutils literal notranslate"><span class="pre">top_id</span></code> applied only if it is greater than
the one used in <code class="docutils literal notranslate"><span class="pre">self</span></code>.</p>
<p>This method creates additional clauses encoding the existing
totalizer tree merged with another totalizer tree into <em>one</em> sum
and updating the upper bound. As a result, it appends the new
clauses to the list of clauses of <a class="reference internal" href="formula.html#pysat.formula.CNF" title="pysat.formula.CNF"><code class="xref py py-class docutils literal notranslate"><span class="pre">CNF</span></code></a> <code class="docutils literal notranslate"><span class="pre">self.cnf</span></code>. The
number of newly created clauses is stored in variable
<code class="docutils literal notranslate"><span class="pre">self.nof_new</span></code>.</p>
<p>Also, if the upper bound is updated, a list of bounds <code class="docutils literal notranslate"><span class="pre">self.rhs</span></code>
gets increased and its length becomes <code class="docutils literal notranslate"><span class="pre">ubound+1</span></code>. Otherwise, it
is updated with new values.</p>
<p>The method can be used in the following way:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysat.card</span> <span class="kn">import</span> <span class="n">ITotalizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="n">t1</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4]]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[3, 4]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span> <span class="o">=</span> <span class="n">ITotalizer</span><span class="p">(</span><span class="n">lits</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">ubound</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8]]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[7, 8]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t1</span><span class="o">.</span><span class="n">merge_with</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">)</span>
<span class="go">[[-2, 3], [-1, 3], [-1, -2, 4], [-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">cnf</span><span class="o">.</span><span class="n">clauses</span><span class="p">[</span><span class="o">-</span><span class="n">t1</span><span class="o">.</span><span class="n">nof_new</span><span class="p">:])</span>
<span class="go">[[-6, 7], [-5, 7], [-5, -6, 8], [-7, 9], [-8, 10], [-3, 9], [-4, 10], [-3, -7, 10]]</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
<span class="go">[9, 10]</span>
<span class="gp">...</span>
<span class="gp">... </span>    <span class="n">t2</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.ITotalizer.new">
<span class="sig-name descname"><span class="pre">new</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lits</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ubound</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">top_id</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.ITotalizer.new" title="Permalink to this definition">#</a></dt>
<dd><p>The actual constructor of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a>. Invoked from
<code class="docutils literal notranslate"><span class="pre">self.__init__()</span></code>. Creates an object of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> given
a list of literals in the sum, the largest potential bound to
consider, as well as the top variable identifier used so far. See
the description of <a class="reference internal" href="#pysat.card.ITotalizer" title="pysat.card.ITotalizer"><code class="xref py py-class docutils literal notranslate"><span class="pre">ITotalizer</span></code></a> for details.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pysat.card.NoSuchEncodingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.card.</span></span><span class="sig-name descname"><span class="pre">NoSuchEncodingError</span></span><a class="headerlink" href="#pysat.card.NoSuchEncodingError" title="Permalink to this definition">#</a></dt>
<dd><p>This exception is raised when creating an unknown an AtMostK, AtLeastK,
or EqualK constraint encoding.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.NoSuchEncodingError.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.NoSuchEncodingError.with_traceback" title="Permalink to this definition">#</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pysat.card.UnsupportedBound">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pysat.card.</span></span><span class="sig-name descname"><span class="pre">UnsupportedBound</span></span><a class="headerlink" href="#pysat.card.UnsupportedBound" title="Permalink to this definition">#</a></dt>
<dd><p>This exception is raised when creating a pairwise, or bitwise, or
ladder encoding of AtMostK, AtLeastK, or EqualsK with the bound
different from <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">N</span> <span class="pre">-</span> <span class="pre">1</span></code>.</p>
<dl class="py method">
<dt class="sig sig-object py" id="pysat.card.UnsupportedBound.with_traceback">
<span class="sig-name descname"><span class="pre">with_traceback</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pysat.card.UnsupportedBound.with_traceback" title="Permalink to this definition">#</a></dt>
<dd><p>Exception.with_traceback(tb) –
set self.__traceback__ to tb and return self.</p>
</dd></dl>

</dd></dl>

</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="../index.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Welcome to PySAT’s documentation!</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="formula.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Boolean formula manipulation (<code class="xref py py-mod docutils literal notranslate"><span class="pre">pysat.formula</span></code>)</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2018-2024, Alexey Ignatiev, Joao Marques-Silva, Antonio Morgado.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 4.5.0.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>